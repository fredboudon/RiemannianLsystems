import sys
sys.path.append("../RiemannTurtleLib")
import numpy as np
from numpy.linalg import norm
import nurbsswung as ns
from importlib import reload
reload(ns)
from math import *

%pastefile ../RiemannTurtleLib/riemannianrules.lpy

def nurbHalfEllipse(xradius = 1, yradius = 1): 
    knots = [0,0,0,0,1,1,1,1]
    def p(point,w) :
        return [pi*r for pi,r in zip(point,[xradius,yradius])]+[w]
    ctrlPoints =  [ p((0,1),1), p((2,1),1/3), p((2,-1),1/3), p((0,-1),1)]
    return NurbsCurve2D(ctrlPoints, knots)

r = 1
profsphere = nurbHalfEllipse(r,r)
swung = ns.NurbsSwung(profileList=[profsphere, profsphere,profsphere],angleList=list(map(radians,[0,180,360])),stride=100, slices=100, ccw=False)

#######################
# Units0.5
#######################
# Scaling model in graphic scene
meter = 1.0 # An object of 1 meter is mapped onto a graphic unit size of 1.0
            # (F(1) for instance corresponds to a forward move of 1 meter)
cm = 0.01 * meter

#######################
# DISPLAY PARAMETERS
#######################

# Flags to control the display
PLOTSPACE = True

# maximum len of subdivision step required to draw any line on the surface
# this controls the resolution of the geodesic plot with respect to the
# surface curvature
MAXSTEPLEN = 1 * cm  # Should be > 0.0

# Width to draw the geodesics
LINEWIDTH  = 1. * cm

# To control the Frame size
FRAMESIZE  = 0.3 * meter
FRAMEWIDTH = 1 * cm

#######################
# SIMULATION PARAMETERS
#######################

nb_seg = 10 # nb of segment to draw the geodesic (defines the parameter of the F)
            # To draw one geodesic, set it to 1 and set dashed to False

length_geodesic = (r*2*np.pi)

module DrawVect

Axiom:
  nproduce ,(2) _(0.01) #@g(swung.discretize())
  # Sets the Riemannian space in which the turtle will move
  patch = Patch(swung, vtoric=True)
  nproduce SetSpace(patch,{'CCW' : True})
  # Sets the initial position of the turtle in this space in the space coordinates: u,v (and p,q their first derivatives)
  v0 = 0
  u0 = 0.5
  
  nb = 10
  a = 10 
  for i in range(nb+1):  
    nproduce [InitTurtle([u0,v0,1,0]) +(a) D InterpolateColors(3,5, i/(nb)) A(nb_seg)]
    a += 160/nb
  


derivation length: nb_seg
production:


A(n):
  if n > 0:
    nproduce F(length_geodesic/nb_seg)
    nproduce A(n-1)

interpretation:
maximum depth: 2


D --> DrawVect(turtle.space.shift_vector(*turtle.uvpq))


endlsystem

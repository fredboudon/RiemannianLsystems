"""
	L-systems in Riemannian geometry
	
		Author: Ch. Godin, Inria
		Date: 2019-2022

	Computation of curvatures on different surfaces
"""

import numpy as np
import numpy.linalg as linalg

# To import libs from other directories
#(append dynamically other dirs to PYTHONPATH variable)
from importlib import reload

import riemann_lsystem.surfaces
surfaces = reload(riemann_lsystem.surfaces)
import riemann_lsystem.riemannianturtle
riemannian_turtle = reload(riemann_lsystem.riemannianturtle)
import riemann_lsystem.lineintersection as li
reload(li)

from riemann_lsystem.lineintersection import *
from riemann_lsystem.surfaces import *
from riemann_lsystem.riemannianturtle import *

%pastefile ../src/riemann_lsystem/riemannianrules.lpy

PRINT_CURVATURES = True

#######################
# Units
#######################
# Scaling model in graphic scene
meter = 1.0 # An object of 1 meter is mapped onto a graphic unit size of 1.0
            # (F(1) for instance corresponds to a forward move of 1 meter)
cm = 0.01 * meter

# Surface parameters
R = 2. * meter   # Radius of the sphere in meter

#######################
# DISPLAY PARAMETERS
#######################

# Flags to control the display
PLOTSPACE = True

# maximum len of subdivision step required to draw any line on the surface
# this controls the resolution of the geodesic plot with respect to the
# surface curvature
MAXSTEPLEN = 20 * cm  # Should be > 0.0

# Width to draw the geodesics
LINEWIDTH  = 3.0 * cm

# To control the Frame size
FRAMESIZE  = 0.3 * meter
FRAMEWIDTH = 1 * cm

#######################
# SIMULATION PARAMETERS
#######################

ra = 1.
rb = 0.5

seglen = ra/10.
length_geodesic =  ra/5

T = 60
dt = 0.04
DT = 0.1
m, n = 11,11

# Set of trajectories already existing since the beginning of the simulation
trajectories = LineSet()

MAXORDER = 2

SEG_ID = 0
LAT_BUD_DELAY = 0
GROW_INTERSECTING_SEGMENTS = False

SHOW_APICES = True
SHOW_TRUNCATED = True

#########################
# Selectiong of tests
#########################

nbbuds = 0
spacegrowth = False

def generate_patch(t):
  nb = 20
  s = 10+t*0.1
  ctrlpoints = [[[s*(p.x*width(i/nb)),#+3*heightshift(i/nb)*p.x),
                  s*(i*0.075),
                  s*(p.y*width(i/nb)+3*heightshift(i/nb)*p.x),p.z] for p in profile.ctrlPointList] for i in range(nb+1)]
  return NurbsPatch(ctrlpoints)
  
def StartEach(lstring):
  global nbbuds
  nbbuds = 0

def EndEach():
  global spacegrowth
  spacegrowth = ( nbbuds == 0 )  
  print(getIterationNb(),nbbuds)

######################
# Test selection
######################
SEGLEN = 2.
BANGLE = 70
MAXORDER = 2
nspace = None

module NSpace
module TestCut

Axiom:
  
  nproduce MySpace(0)
  
  #nproduce ;(0)PlotSpace(dic)
  # Sets the initial position of the turtle in this space in the space coordinates: u,v (and p,q their first derivatives)
  u0= 0.006
  v0= 0.5
  nproduce InitTurtle([u0,v0,1,0]) ;(5) _(LINEWIDTH) @O
  nproduce -(0.15) ?T() A(0,0,0)


derivation length: 90
production:

MySpace(t) :
  global MAXORDER
  if spacegrowth:
    print('Growth')
    MAXORDER += 1
    produce MySpace(t+DT)

?T(t):
  delta = 0.005
  if t.uvpq[0] < delta or t.uvpq[0] > 1-delta or t.uvpq[1] < delta or t.uvpq[1] > 1-delta:
    produce % 

# state = 1 is 'spatially blocked'
# state = 0 is 'spatially free to go'
# delay = n is the amount of time the bud must wait before being activated 
?T(t)A(delay, order,state):
    global nbbuds
    #if delay == 0 and order < MAXORDER and (rank < 2 or order == 0):
    if delay < 0 and order < MAXORDER:
      uvpq_s = forward(t,SEGLEN, MAXSTEPLEN)
      #print("forward : ", uvpq_s)
      #if np.linalg.norm(uvpq_s[0]-t.uvpq) < 1e-5:
      #  uvs = [(s[0],s[1]) for s in uvpq_s]
      
      # Construct the corresponding line made of uv coords
      # 1. The turtle has current coordinates uvpq
      curpos = [(t.uvpq[0],t.uvpq[1])]
      # 2. Make the list of all uv positions on the path, including current postion in front
      uvs = curpos+[(s[0],s[1]) for s in uvpq_s]
      
      # Test whether this new line intersects the previously stored lines:
      # if no intersection, the function returns a boolean
      # else: the function returns an array of 4 values:
      #  0: pt_id before intersection, 
      #  1: pt_id before intersection of intersected line, 
      #  2: line_id of intersected line,
      #  3: found intersection point
      intersection = trajectories.test_intersection(uvs)
      
      if not intersection:
        nbbuds += 3
        # update the stored lines with the new line
        trajectories.add_line_from_point(t.uvpq,uvs)
        
        # plot the forward path:
        # acts like a F but the sequence of coordinates uv is given instead of path length
        nproduce P(uvpq_s)
        nproduce [+(BANGLE)?T()A( 1, order+1, 0)]
        nproduce [-(BANGLE)?T()A( 1, order+1, 0)]
        nproduce ?T()A( 0, order, 0)
      #else: # intersection detected
      #  # 1. computes the intersected segment up to intersection point (truncated line)
      #  # Retrieves the point uvpq coords of the detected intersection point
      #  intersec_pt = intersection[3]       # point exactly at the intersection of the 2 intersecting segments
      #  intersec_pt_before = uvpq_s[intersection[0]] # to get pq of last intersection point (approximation only)
      #  lastuvpq = [intersec_pt[0],intersec_pt[1],intersec_pt_before[2],intersec_pt_before[3]]
      #  # Take the first pts of the uvpq_s line up to point just before intersection 
      #  # and add the exact intersection pt.
      #  totaluvpq = uvpq_s[:intersection[0]]+[lastuvpq]
      #  # update stored existing lines with this new truncated line
      #  if GROW_INTERSECTING_SEGMENTS:
      #    trajectories.add_line_from_point(t.uvpq, [(s[0], s[1]) for s in totaluvpq])
      #  if intersection[0] > 0:
      #    if SHOW_TRUNCATED:
      #      c = 0
      #    else:
      #      c = 5
      #    nproduce [;(c)P(totaluvpq)]
      #  else:
      #    nproduce ?T(t)A(order,rank,delay,1)
      
    else:
      nbbuds += 1
      nproduce ?T(t)A(delay-1,order, state)



P(uvpq_s):
  leng = nspace.path_length(uvpq_s)
  if leng > SEGLEN*1.05 and len(uvpq_s) > 1:
    global nbbuds
    nbbuds += 3
    nproduce P(uvpq_s[:int(len(uvpq_s)/2)])
    nproduce [,(6)@Di(2) @O]
    nproduce [+(BANGLE)?T(ParameterSet())A(0, 0)]
    nproduce [-(BANGLE)?T(ParameterSet())A(0, 0)]
    nproduce P(uvpq_s[int(len(uvpq_s)/2):])

interpretation:

MySpace(t):
  global nspace
  npatch = generate_patch(t)
  nspace = Patch(npatch)
  nproduce ,(2) @g(npatch)
  nproduce SetSpace(nspace)
  
A(delay, order,  state):
  color = 3 if delay == 1 else 4 if state == 1 else 2
  if SHOW_APICES:
    nproduce F(0.2);(color)@O(0.1)

endlsystem


###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_14 = pgl.Material("Color_14" , transparency = 0.45 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
	context.animation_timestep = 0.001
	scalars = [('a', 'Float', 1.0, 0.1, 5.0, 2), ('b', 'Float', 2.87, 0.1, 5.0, 2)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
	import openalea.plantgl.all as pgl
	patch1 = pgl.NurbsPatch(	
	    pgl.Point4Matrix([[(0, -0.5, 0, 1), (0.0295491, 0.0172273, 0.0204014, 1), (0.0012238, 0.186899, 0.00203897, 1), (0, 0.5, 0, 1)], [(-0.0337475, -0.532502, 0.259858, 1), (0.325603, 0.00690836, 0.425017, 1), (0.303992, 0.200873, 0.366263, 1), (0.00594731, 0.473902, 0.221347, 1)], [(-0.00441042, -0.518639, 0.489863, 1), (0.346984, -0.0268568, 0.48347, 1), (0.334252, 0.212297, 0.456407, 1), (-0.0147519, 0.496314, 0.461605, 1)], [(0, -0.5, 0.666667, 1), (0.367414, 0.0717941, 0.599293, 1), (0.325871, 0.177369, 0.550018, 1), (0, 0.5, 0.666667, 1)], [(0, -0.5, 1, 1), (0, -0.166667, 1, 1), (0.000294821, 0.152723, 1.00003, 1), (0, 0.5, 1, 1)]]) , 
vstride = 20 , 	    )
	patch1.name = "patch1"
	import openalea.plantgl.all as pgl
	vasefunc = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.00200282, 1),(0.0160347, 0.559939, 1),(0.440107, -0.0643654, 1),(0.905046, 0.267064, 1),(1, 0.135477, 1),(1, 0.00596927, 1)]) , 
	    )
	vasefunc.name = "vasefunc"
	import openalea.plantgl.all as pgl
	profile = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.5, 0.132189, 1),(-0.437672, 0.14246, 1),(-0.166667, 0, 1),(-0.0557936, -0.0249787, 1),(0.0822702, -0.0279162, 1),(0.219542, -0.0117501, 1),(0.487649, 0.151273, 1),(0.570501, 0.114564, 1)]) , 
	    stride = 48 , 
	    )
	profile.name = "profile"
	width = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.0262652, 1),(0.175742, 0.998078, 1),(0.565358, 0.694152, 1),(1, 0.0316075, 1)]) , 
	    )
	width.name = "width"
	heightshift = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0, 1),(0.0966414, 0.0637869, 1),(0.19795, -0.101309, 1),(0.303316, 0.0825478, 1),(0.411824, -0.0637869, 1),(0.505628, 0.0712913, 1),(0.621946, -0.0487783, 1),(0.704188, 0.0675391, 1),(0.832067, -0.0412739, 1),(0.910863, 0.0562826, 1),(1, 0, 1)]) , 
	    stride = 66 , 
	    )
	heightshift.name = "heightshift"
	panel_0 = ({'name': 'Panel 2', 'active': True, 'visible': True},[('NurbsPatch',patch1),('Function',vasefunc),('Curve2D',profile),('Function',width),('Function',heightshift)])
	parameterset = [panel_0,]
	context["__functions__"] = [('vasefunc',vasefunc),('width',width),('heightshift',heightshift),]
	context["__curves__"] = [('profile',profile),]
	context["__parameterset__"] = parameterset
	context["patch1"] = patch1
	context["vasefunc"] = pgl.QuantisedFunction(vasefunc)
	context["profile"] = profile
	context["width"] = pgl.QuantisedFunction(width)
	context["heightshift"] = pgl.QuantisedFunction(heightshift)
__references__ = '##'

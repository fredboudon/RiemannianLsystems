"""
	L-systems in Riemannian geometry
	
		Author: Ch. Godin, Inria
		Date: 2019-2022

	Computation of curvatures on different surfaces
"""

import numpy as np
import numpy.linalg as linalg

# To import libs from other directories
#(append dynamically other dirs to PYTHONPATH variable)
from importlib import reload

import riemann_lsystem.surfaces
surfaces = reload(riemann_lsystem.surfaces)
import riemann_lsystem.riemannianturtle
riemannian_turtle = reload(riemann_lsystem.riemannianturtle)

from riemann_lsystem.surfaces import *
from riemann_lsystem.riemannianturtle import *

%pastefile ../src/riemann_lsystem/riemannianrules.lpy

PRINT_CURVATURES = True

#######################
# Units
#######################
# Scaling model in graphic scene
meter = 1.0 # An object of 1 meter is mapped onto a graphic unit size of 1.0
            # (F(1) for instance corresponds to a forward move of 1 meter)
cm = 0.01 * meter

# Surface parameters
R = 2. * meter   # Radius of the sphere in meter

#######################
# DISPLAY PARAMETERS
#######################

# Flags to control the display
PLOTSPACE = True

# maximum len of subdivision step required to draw any line on the surface
# this controls the resolution of the geodesic plot with respect to the
# surface curvature
MAXSTEPLEN = 1 * cm  # Should be > 0.0

# Width to draw the geodesics
LINEWIDTH  = 1. * cm

# To control the Frame size
FRAMESIZE  = 0.3 * meter
FRAMEWIDTH = 1 * cm

#######################
# SIMULATION PARAMETERS
#######################
def vase(x, *args):
  if x < 0: 
    x = 0.
  u = (x) / 10.
  radius = 10
  return radius*vasefunc.getValue(u)


ra = 1.
rb = 0.5

seglen = ra/10.
length_geodesic =  ra/5

#########################
# Selectiong of tests
#########################

TEST = 1           # To test different parametric surfaces
PRINT_TEST = 2     # To print different types of results related to curvature

Axiom:
  # Sets the Riemannian space in which the turtle will move
  dic = {}
  dic = dict(CCW = False) 
  nproduce SetSpace(Patch(patch1))
  nproduce ;(0)PlotSpace(dic)
  # Sets the initial position of the turtle in this space in the space coordinates: u,v (and p,q their first derivatives)
  u0= 0.01 #np.pi/6
  v0= 0 #np.pi/6
  a = np.pi/3. # to orient the turtle's head at the beginning
  nproduce InitTurtle([u0,v0,np.cos(a),np.sin(a)])
  #nproduce InitTurtle([u0,v0,0,1])
  nproduce ;(1)_(LINEWIDTH) S

derivation length: int(length_geodesic/seglen)
production:

interpretation:

maximum depth: 3

S:
  
A(scalefactor,color_plus,color_minus,linewidth):
  
endlsystem


###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_14 = pgl.Material("Color_14" , transparency = 0.45 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
	context.animation_timestep = 0.001
	scalars = [('a', 'Float', 1.0, 0.1, 5.0, 2), ('b', 'Float', 2.87, 0.1, 5.0, 2)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
	import openalea.plantgl.all as pgl
	patch1 = pgl.NurbsPatch(	
	    pgl.Point4Matrix([[(0, -0.5, 0, 1), (0.0295491, 0.0172273, 0.0204014, 1), (0.0012238, 0.186899, 0.00203897, 1), (0, 0.5, 0, 1)], [(-0.0337475, -0.532502, 0.259858, 1), (0.325603, 0.00690836, 0.425017, 1), (0.303992, 0.200873, 0.366263, 1), (0.00594731, 0.473902, 0.221347, 1)], [(-0.00441042, -0.518639, 0.489863, 1), (0.346984, -0.0268568, 0.48347, 1), (0.334252, 0.212297, 0.456407, 1), (-0.0147519, 0.496314, 0.461605, 1)], [(0, -0.5, 0.666667, 1), (0.367414, 0.0717941, 0.599293, 1), (0.325871, 0.177369, 0.550018, 1), (0, 0.5, 0.666667, 1)], [(0, -0.5, 1, 1), (0, -0.166667, 1, 1), (0.000294821, 0.152723, 1.00003, 1), (0, 0.5, 1, 1)]]) , 
vstride = 20 , 	    )
	patch1.name = "patch1"
	import openalea.plantgl.all as pgl
	vasefunc = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.00200282, 1),(0.0160347, 0.559939, 1),(0.440107, -0.0643654, 1),(0.905046, 0.267064, 1),(1, 0.135477, 1),(1, 0.00596927, 1)]) , 
	    )
	vasefunc.name = "vasefunc"
	panel_0 = ({'name': 'Panel 2', 'active': True, 'visible': True},[('NurbsPatch',patch1),('Function',vasefunc)])
	parameterset = [panel_0,]
	context["__functions__"] = [('vasefunc',vasefunc),]
	context["__curves__"] = []
	context["__parameterset__"] = parameterset
	context["patch1"] = patch1
	context["vasefunc"] = pgl.QuantisedFunction(vasefunc)
__references__ = '#'

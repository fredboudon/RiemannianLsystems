%pastefile ../RiemannTurtleLib/riemannianrules.lpy
"""
	L-systems in Riemannian geometry

		Author: Ch. Godin, Inria
		Date: 2019-2022

   Test the growth of a tree in a purely Riemannian space (2D)

"""

import numpy as np
from math import ceil
from random import random, seed

# To import libs from other directories
#(append dynamically other dirs to PYTHONPATH variable)
import sys
sys.path.append("../RiemannTurtleLib")

from importlib import reload

import surfaces
surfaces = reload(surfaces)
import riemannianturtle
riemannian_turtle = reload(riemannianturtle)

from surfaces import *
from riemannianturtle import *


# Flags to control the display
PLOTSPACE = True

######################################
# DEFINITION OF THE METRIC (INTRINSIC)
######################################

# Point source metric : metric generated by a point source

# Parameters used both for psi and psd metric
# metric is diagonal in the local frame (r,theta). 
# These formula define r, theta, and control ratio parameters
def ps_params(u,v,source,ry,rz):
    p = np.array((u, v))
    s = np.array(source)
    r = np.linalg.norm(s - p)

    costheta = (s[0] - u) / r
    sintheta = (s[1] - v) / r

    ratioy = r / ry
    ratioz = r / rz
    return r,costheta,sintheta,ratioy,ratioz

# Point source metric (psi) (increasing with radius to the source)
def g11_psi(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v, *args)
    return ratioy*costheta**2 + ratioz*sintheta**2
# g11 with swapped u,v --> v,u (to carry out devivative of first argument)
def g11s_psi(v,u,*args):
    return g11_psi(u,v,*args)

# g12 == g21
def g12_psi(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v,*args)
    return (ratioy-ratioz)*costheta*sintheta
def g12s_psi(v,u,*args):
    return g12_psi(u,v,*args)

def g22_psi(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v,*args)
    return ratioy*sintheta**2 + ratioz*costheta**2
def g22s_psi(v,u,*args):
    return g22_psi(u,v,*args)

#######################
# Units
#######################
# Scaling model in graphic scene
meter = 1.0 # An object of 1 meter is mapped onto a graphic unit size of 1.0
            # (F(1) for instance corresponds to a forward move of 1 meter)
cm = 0.01 * meter

# Surface parameters
R = 1. * meter   # Radius of the sphere in meter

#######################
# DISPLAY PARAMETERS
#######################


# maximum len of subdivision step required to draw any line on the surface
# this controls the resolution of the geodesic plot with respect to the
# surface curvature
MAXSTEPLEN = 1 * cm  # Should be > 0.0

# Width to draw the geodesics
LINEWIDTH  = 2 * cm

# To control the Frame size
FRAMESIZE  = 0.3 * meter
FRAMEWIDTH = 1.0 * cm

#######################
# SIMULATION PARAMETERS
#######################

TREE = True
sun = (1.,1.5) # source of attraction

# Tighten the nec of the pin form structure to see that the geodesic 
# at some threshold is doomed to stay in the lower part and cannot reach the other part
nb_seg = 10 # nb of segment to draw the geodesic (defines the parameter of the F)
            # To draw one geodesic, set it to 1 and set dashed to False
ilen = 0.4 # 
seed(0)

#Metric parameters for psi and psd
source = (0.5,1.5)
ry = 1.
rz = 2.

TEST = 1

Axiom: 
  global source
  if TEST == 1: # FIXME: it seems that the segments are much longer close to the source and that on the left there is repulsion while attraction on the right !!
    source = (-0.1,2)
  else:
    source = (0.5,1.5)
  # Sets the Riemanian space in which the turtle will move
  # Sets the Riemanian space in which the turtle will move
  params = (source, ry, rz)
  # choice of functions used to define the intrinsic metric (see above their definition
  metric_funcs = {'g11' : g11_psi, 'g12' : g12_psi, 'g22' : g22_psi, 'g11s' : g11s_psi, 'g12s' : g12s_psi, 'g22s' : g22s_psi}
  #metric_funcs = {'g11' : g11_psd, 'g12' : g12_psd, 'g22' : g22_psd, 'g11s' : g11s_psd, 'g12s' : g12s_psd, 'g22s' : g22s_psd}
  nproduce SetSpace(RiemannianSpace2D(**metric_funcs, umin = -2, umax = 2., vmin = 0, vmax = 3, metric_tensor_params = params))
  nproduce ;(0)PlotSpace
  nproduce PlotDS2(dict(DS2_SCALEFACTOR = 5))
  nproduce InitTurtle([0.0,0.0,0.0,1.])
  # nproduce InitTurtle([0.9,1.4,-0.7,-0.2]) # Gowing away from the source ...

  # for hyperbolic geometry:
  # just uncomment the hyperbolic metric in surfaces.py and comment the other one
  # Geodesics are semi-circles of the Poincar√©-Beltrami half plane
  #nproduce InitTurtle([-1.5,0.1,0.3,0.9])
  
  nproduce S;(6)_(LINEWIDTH)A(0)@O(0.03)_(FRAMEWIDTH)Frame(FRAMESIZE)
 

derivation length: 6 # set to 12 for a hyperbolic geodesic, and 7 for hyperbolic tree
production:

A(n):
  # branching angle
  if n % 2 == 0:
    ba = 30
  else:
    ba = -30
  nproduce F(ilen) 
  if TREE:
    nproduce [+(ba)A(n+1)]
  nproduce A(n+1)

interpretation:

A(n):
  produce ;(2)@O(0.03)

S: 
  produce [MoveTo(turtle.space.S(*source));(4)@O(0.1)]

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_14 = pgl.Material("Color_14" , transparency = 0.45 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
	context.animation_timestep = 0.001
	scalars = [('a', 'Float', 1.0, 0.1, 5.0, 2), ('b', 'Float', 2.87, 0.1, 5.0, 2)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
__references__ = '#'


# Lane and Riesenfeld algo for generating BSpline with subdivision


import numpy as np
from math import *
from random import random, uniform, seed

from importlib import reload

import riemann_lsystem
import riemann_lsystem.surfaces
surfaces = reload(riemann_lsystem.surfaces)
import riemann_lsystem.riemannianturtle
riemannian_turtle = reload(riemann_lsystem.riemannianturtle)

from riemann_lsystem.surfaces import *
from riemann_lsystem.riemannianturtle import *
import openalea.plantgl.all as pgl

%pastefile ../src/riemann_lsystem/riemannianrules.lpy

line = [[0.30000000000000004, 1.0000000000000002] ,[0.23648476759471587, 0.7922510357735477] ,[0.22673697713643112, 0.5131108392613175] ,[0.36243647283565084, 0.4012488074193659] ,[0.43045958182016286, 0.2617807657522538] ,[0.45390147124884334, -0.0061612564931122216] ,[0.320396611063686, -0.1968259564569293] ,[0.23573474567661723, -0.10603722108351502] ,[0.3573454875302324, 0.061345605338887915] ,[0.2535148761986854, 0.1766611817060698] ,[0.050683787296537414, -0.1356713056667088] ,[0.30199669571659604, -0.502704551452571], 
[-0.06432869433329086, -0.7493162127034625], [-0.37666118170606944, -0.5464851238013145], [-0.26134560533888757, -0.44265451246976756], [-0.09396277891648465, -0.5642652543233827], [-0.0031740435430703817, -0.47960338893631393], [-0.19383874350688746, -0.3460985287511566], [-0.46178076575225346, -0.36954041817983707], [-0.6012488074193656, -0.4375635271643491], [-0.7131108392613172, -0.5732630228635688], [-0.9922510357735475, -0.563515232405284], [-1.2, -0.49999999999999983], 
[-1.127667507455128, -0.3641618665741517] ,[-0.9929916450906482, -0.21973968577889297] ,[-0.8692295736267677, -0.23165661784310576] ,[-0.7654996650657598, -0.1959395460015387] ,[-0.61982971037528, -0.07370794074714591] ,[-0.591254106379728, 0.08835236267742343] ,[-0.6789661592393488, 0.0852893902978646] ,[-0.701848745470406, -0.05918557317815519] ,[-0.8114052925332225, -0.06492718851563543] ,[-0.7566628612777714, 0.1926157018348144] ,[-0.4475364728347135, 0.2504671329725107],
[-0.14311062161889565, 0.30761081526851863], [-0.0883681903634445, 0.5651537056189685], [-0.19792473742626093, 0.5594120902814883], [-0.22080732365731817, 0.4149371268054685], [-0.30851937651693895, 0.4118741544259097], [-0.2799437725213869, 0.573934457850479], [-0.1342738178309071, 0.6961660631048718], [-0.030543909269899305, 0.7318831349464389], [0.09321816219398127, 0.719966202882226], [0.22789402455846092, 0.8643883836774848], [0.30000000000000004, 1.]]

s = 0.7
line = [[u*s,v*s] for u,v in line]


ra = 5.
rb = 8
nb = 25
heigth = 0.8

SPACE = 2

def uvcenter(uvs, center, scale):
    umean = sum([u for u,v in uvs])/len(uvs)
    vmean = sum([v for u,v in uvs])/len(uvs)
    return [[center[0]+(u-umean)*scale,center[1]+(v-vmean)*scale] for u,v in uvs]

def uvrotate(uv, center, angle):
    nc = [(u-c) for u,c in zip(uv,center)]
    rand= radians(angle)
    rot = [nc[0]*cos(rand)-nc[1]*sin(rand) +center[0],
            nc[0]*sin(rand)+nc[1]*cos(rand) +center[1]]
    return rot

seed(0)

def rock(ra,rb,h):
  def sphericalcoord(i,j,r1, r2, n):
    return [cos(pi*(j/nb)-pi/2)*cos(2*pi*(i/nb)-pi)*(r1+n), 
           cos(pi*(j/nb)-pi/2)*sin(2*pi*(i/nb)-pi)*(r1+n), 
           sin(pi*(j/nb)-pi/2)*(r2), 1]

  pts = [[sphericalcoord(i,j,ra,rb,h*uniform(-1,1))  for j in range(nb+1)] for i in range(nb)]
  pts.append(pts[0])
  for i in range(1,nb+1):
    pts[i][0] = pts[0][0]
    pts[i][-1] = pts[0][-1]
  return pts
   
npatch = NurbsPatch(rock(ra,rb,heigth), ustride= 200, vstride=200, ccw=False)


CTRLPTS = True
SUBDIV = True
Axiom: 
  global line
  sphere = EllipsoidOfRevolution(ra,rb)
  if SPACE == 1:
    nproduce SetSpace(EllipsoidOfRevolution(ra,rb)) 
    #nproduce ;(0) PlotSpace 
    nproduce ;(0) @g(pgl.Scaled(ra,ra,rb,pgl.Sphere(1, 30,30))) 
    nproduce InitTurtle([0,-1,0,1]) 
  else:
    nproduce ;(0)@g(npatch)     
    nproduce SetSpace(Patch(npatch))
    nproduce InitTurtle([0.5,0.2,0,1])
    line = [[(u+2)/4, (v+2.2)/3] for u,v in line]
    line = uvcenter(line, [0.5,0.5], 1)
    line = [uvrotate(uv,[0.5,0.5],45) for uv in line]
  if CTRLPTS:
      nproduce InitTurtle([line[0][0],line[0][1],1,0]) ,(5)
      nproduce [_(0.04) [,(3)@O(0.1)] StartBSpline(2)
      for pt in line[1:]:
        nproduce @Gc RiemannLineTo(pt,10) @Ge
        #nproduce RiemannMoveTo(pt) 
        nproduce [,(3)@O(0.1)] #BSplinePoint()
      nproduce EndBSpline() ]
  if SUBDIV:
      nproduce InitTurtle([line[0][0],line[0][1],1,0]) @Gc
      nproduce [,(2)_(0.08) BSplineSubdivision(line, 2)
      nproduce ]
  #nproduce  ,(2)_(0.1)@Gc() 



def StartEach():
  pass

derivation length: 7
production:

BSplineSubdivision(points, d) --> BSplineSubdivision(points, d+1)

endlsystem

###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_5 = pgl.Material("Color_5" , ambient = (0,0,0) , diffuse = 40 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	scalars = [('DEGREE', 'Integer', 2, 1, 6), ('DERIVATION', 'Integer', 3, 1, 20), ('POINTS', 'Bool', True), ('GEODESICDISTANCE', 'Bool', True)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
	import openalea.plantgl.all as pgl
	curve = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.763601, 0.0753145, 1),(-0.273579, 0.224159, 1),(-0.285018, -0.301258, 1),(-0.0442948, -0.54963, 1),(0.231222, 0.204425, 1),(0.435962, -0.192388, 1),(0.747462, 0.182907, 1)]) , 
	    stride = 42 , 
	    )
	curve.name = "curve"
	panel_0 = ({'name': 'Panel 2', 'active': True, 'visible': True},[('Curve2D',curve)])
	parameterset = [panel_0,]
	context["__functions__"] = []
	context["__curves__"] = [('curve',curve),]
	context["__parameterset__"] = parameterset
	context["curve"] = curve
__references__ = 'Przemyslaw Prusinkiewicz, Mitra Shirmohammadi, and Faramarz Samavati. L-systems in Geometric Modeling. Proceedings of the Twelfth Annual Worskshop on Descriptional Complexity of Formal Systems, pp. 3-12, 2010. '

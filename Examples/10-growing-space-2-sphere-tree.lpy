"""
	L-systems in Riemannian geometry

		Authors: F. Boudon, Ch. Godin
		Date: 2023
		
	Simulates geodesics on a sphere with a riemannian implementation of
	the main turtle primitives: F, f, + and -

	- To draw a geodesic of length L set with 10 segments of equal size (L/10): length_geodesic = L, nb_seg = 10
	- TODO: take a convention where principal curvatures are counted positive for the sphere ?

"""

import numpy as np
from math import ceil, exp
from random import random

from importlib import reload

import riemann_lsystem
import riemann_lsystem.surfaces
surfaces = reload(riemann_lsystem.surfaces)
import riemann_lsystem.riemannianturtle
riemannian_turtle = reload(riemann_lsystem.riemannianturtle)

from riemann_lsystem.surfaces import *
from riemann_lsystem.riemannianturtle import *
import riemann_lsystem.lineintersection as li
reload(li)

from riemann_lsystem.lineintersection import *

from openalea.plantgl.all import *

%pastefile ../src/riemann_lsystem/riemannianrules.lpy

#######################
# Units
#######################
# Scaling model in graphic scene
meter = 100.0 # An object of 1 meter is mapped onto a graphic unit size of 1.0
            # (F(1) for instance corresponds to a forward move of 1 meter)
cm = 0.01 * meter

# Surface parameters
R = 2. * meter   # Radius of the sphere in meter
dR = 0.5 * meter

#######################
# DISPLAY PARAMETERS
#######################


# maximum len of subdivision step required to draw any line on the surface
# this controls the resolution of the geodesic plot with respect to the
# surface curvature
MAXSTEPLEN = 5 * cm  # Should be > 0.0

# Width to draw the geodesics
LINEWIDTH  = 5 * cm


#######################
# SIMULATION PARAMETERS
#######################


length_greatcircle = 2*np.pi*R

max_order  = 2
max_rank = 5
seglen = length_greatcircle/(2.5*max_rank)

u0= pi
v0= (-pi/2) * (6/10.)
p0 = 0.0 # 0.001 # 0.03
q0 = 1.

lineset = LineSet()
budid = 0

nb_initstep = max_rank
nb_growthstep = 20


DETECT_RATIO = 1.3

activebuds = 1
spacegrowth = False

space = None

def Start():
  global budid 
  budid = 1

def StartEach():
  global lineset, activebuds
  frameDisplay(True)
  lineset = LineSet()
  activebuds = 0

def EndEach(lstring, lscene):
  global activebuds, spacegrowth
  assert not lscene is None
  print('*******',getIterationNb())
  if activebuds == 0:
    # Flag indicating whether the space must grow (or not)
    spacegrowth = True


# function of the number of boxes intersecting a point
def energy(u,v):
  return lineset.nb_bboxes((u,v))

def energy2(u,v):
  a = int(divmod(u,pi/10)[0])
  b = int(divmod(v,pi/10)[0])
  if a % 2:
    return b % 2
  else :
    return 1 - (b % 2)

def to_uv(uvpq, minindex = 0, maxindex = -1):
  return [(u,v) for u,v,p,q in uvpq]

module MySpace(time, space)
module PotentialMetamer
module Segment

Axiom:
  global budid
  # Sets the Riemannian space in which the turtle will move
  nproduce MySpace(0, EllipsoidOfRevolution(R,1.5*R))
  dx = 0.05  # dx in the vizualization of MySpace
  nproduce ;(0)PlotSpace() #energy, 'jet', dx, dx)
  # Sets the initial position of the turtle in this space in the space coordinates: u,v (and p,q their first derivatives)
  nproduce _(LINEWIDTH)[InitTurtle([u0,v0,p0,q0]);(1) +(1)  A(0, 0, max_rank, {'intersect' : False}, budid)]
  budid +=1

derivation length: nb_initstep +nb_growthstep
production:

MySpace(t, space):
  global R, max_order, spacegrowth
  if spacegrowth:
    # Simulate growth of the space
    print('Growth')
    R += dR
    spacegrowth = False    
    # Allow tree structure to ramify more after initialization
    max_order = 5
    
  space = EllipsoidOfRevolution(R,1.5*R) # Sphere(R)
  nproduce MySpace(t+1, space)

PotentialMetamer(length, order, rank, max_rank, segmentinfo, bid):
  # n contains the rank of the segment.
  # r the order of ramification.
  # max_rank the maximum rank allowed.
  # test is the result of the intersection test made in the interpretation part.
  global lineset, budid
  
  bangle = 60
  if 'uvpq' in segmentinfo and len(segmentinfo['uvpq']) > 0:
      # segment info should have been computed.
      uvpqs = segmentinfo['uvpq']
      if segmentinfo['intersect']:
        # if intersection occurs
        if DORMANT_BUD:
          nproduce  A(order, rank, max_rank, segmentinfo, bid)          
        elif LINKVEINS:
          lineset.add_line(to_uv(uvpqs,maxindex=segmentinfo['intersectpos']), bid)
          nproduce Segment(uvpqs, order, bid)
      else:
        
        lineset.add_line(to_uv(uvpqs), bid)        
        nproduce Segment(uvpqs, order, bid)
        
        if rank < max_rank-1:
          mrank = max_rank-rank
          nproduce [+(bangle * pow(-1,order)) A(order+1, 0, mrank, {}, budid) ]
          nproduce [-(bangle * pow(-1,order)) A(order+1, 0, mrank, {}, budid+1) ]
          nproduce  A(order, rank+1, max_rank, {}, budid+2)
          budid += 3

Segment(uvpqs, order, bid):
  # Register segment in the intersections object to make it detectable when testing new growth
  global lineset
  lineset.add_line(to_uv(uvpqs), bid)

decomposition:
A(order, rank, max_rank, segmentinfo, bid):
  # - order the order of ramification.
  # - rank contains the rank of the segment.
  # - max_rank the maximum rank allowed.
  # - segmentinfo is the result of the estimation of potential positioning o. 
  #   It is a dictionnary with : 'intersect' : boolean that contains the result of the test of intersection
  #                              'uvpq' : list of uvpq coordinates of the potential line generated by this apex
  #                              'intersectpos' : The id of the point after which the intersection occurs
  if (order < max_order and rank <= max_rank) :
    length = seglen*pow(0.6,order)
    produce PotentialMetamer(length, order, rank, max_rank, segmentinfo, bid)

interpretation:
maximum depth: 2

Segment(uvpq, order, bid):
  turtle.setId(bid)
  
  if ID:
    # display id
    nproduce [RiemannMoveTo(uvpq[1][:2]) RiemannPinpoint(uvpq[1][2:])^(90)f(5),(10) Label(str(bid),16)]
  
  nproduce _(LINEWIDTH/(1+order)),(1) #InterpolateColors(4,6,it/(nb_initstep+nb_growthstep)) 
  produce @Gc StaticF(0,{'uvpq':uvpq}) @Ge

MySpace(t, space):
  produce SetSpace(space)

PotentialMetamer(length, order, rank, max_rank, segmentinfo, bid):
    global lineset 
    segmentinfo.clear()
    uvpq_s = forward(turtle, length*DETECT_RATIO, MAXSTEPLEN)
    bbx = bbox(uvpq_s)
    
    # Check if forward is still in the domain
    if bbx[0][0] < turtle.space.umin or bbx[1][0] > turtle.space.umax or bbx[0][1] < turtle.space.vmin or bbx[1][1] > turtle.space.vmax:
      # We should compute the actual position of intersection with bounds
      intersection == True
    else:
      segmentinfo['uvpq']=uvpq_s[:int(len(uvpq_s)/DETECT_RATIO)]
      intersection = lineset.test_intersection(to_uv(uvpq_s))
    
    if not intersection is False :
        # Intersection occurs
        segmentinfo['intersect'] = True
        segmentinfo['intersectpos'] = intersection[0]
    else :
      # No intersection
      global activebuds
      activebuds += 1
      segmentinfo['intersect'] = False      
      # Register potential segment for next test
      sid = lineset.add_line(to_uv(uvpq_s),  bid)
    
    if DISPLAY_BUDS:
      # display a sphere
      nproduce ,(2 if not segmentinfo['intersect'] else 3)@Di(2) @O()
    if ID:
      # display id
      nproduce [RiemannMoveTo(uvpq_s[1][:2]) RiemannPinpoint(uvpq_s[1][2:])^(90)f(5),(10) Label(str(bid),16)]
      nproduce ,(3 if intersection else 2)[@Gc StaticF(length,{'uvpq':uvpq_s})]


endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_7 = pgl.Material("Color_7" , transparency = 0.9 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_10 = pgl.Material("Color_10" , ambient = (0,0,0) , diffuse = 40 , shininess = 0 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_14 = pgl.Material("Color_14" , transparency = 0.45 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
	context.animation_timestep = 0.001
	scalars = [('LINKVEINS', 'Bool', False), ('DORMANT_BUD', 'Bool', True), ('ID', 'Bool', False), ('DISPLAY_BUDS', 'Bool', True)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
	import openalea.plantgl.all as pgl
	pinfunc = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.05, 1),(0.0606061, 0.663636, 1),(0.329545, 0.213636, 1),(0.725758, 0.131818, 1),(1, 0.118182, 1)]) , 
	    )
	pinfunc.name = "pinfunc"
	panel_0 = ({'name': 'Panel 2', 'active': True, 'visible': False},[('Function',pinfunc)])
	parameterset = [panel_0,]
	context["__functions__"] = [('pinfunc',pinfunc),]
	context["__curves__"] = []
	context["__parameterset__"] = parameterset
	context["pinfunc"] = pgl.QuantisedFunction(pinfunc)

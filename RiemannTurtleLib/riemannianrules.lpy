"""
	L-systems in Riemannian geometry

		Author: Ch. Godin, Inria
		Date: 2019-2020

	Interpretation rules to simulate geodesics on a curved surface with a riemannian implementation of
	the main turtle primitives: F, f, + and -

"""
#######################################################
# Generic Interpretation rules for Riemannian geometry
# (DO NOT EDIT)
#######################################################
# To import libs from other directories
#(append dynamically other dirs to PYTHONPATH variable)
from math import ceil

import sys
sys.path.append("../RiemannTurtleLib")

from importlib import reload

import surfaces
surfaces = reload(surfaces)
import riemannianturtle
riemannian_turtle = reload(riemannianturtle)

from surfaces import *
from riemannianturtle import *

module SetSpace(surface, argdict)
module InitTurtle(turtle_state)
module ParallelTransportedArrow(angleRelHead,size)
module LineTo(uvcoords, stepnb)
module CovariantBasis(size)
module RiemannLineTo
#module DrawVect(vect) #FIXME: we should be able to declare same module with different signatures
module DrawVect(vect,size)
module DrawPoint

#Default values --> can be redefined below in the main file if needed
PLOTSPACE = True
PLOTDS2 = False

production:
interpretation:

# Two parameters are added to the turtle
# - turtle.space is added by SetSpace refers to the Riemanian space
# in which the turtle is moving
# - turtle.uvpq is added by init, refers to the initial position and velocity
# of the turtle.
# Sets the Riemannian space used by the turtle and draw it if required
# Plots the ds2 field if required
# A second argument is an array of optional parameters:
# args[0] --> DS2_SCALEFACTOR  (= 4 by default) to display the metrics ds2

# TODO: currently no optinal argument can be passed to LPy modules. Making it possible will simplify this call with a dict
SetSpace(surface, argdict):

  #print(argdict)
  CCW = True
  DS2_SCALEFACTOR = 10.
  PLOTDS2 = False
  if not argdict == None:
    if 'CCW' in argdict:
      # if additional argments are given, the first is ccw
      # ccw = boolean to plot quads counter clockwise or not
      CCW = argdict['CCW']
    if 'PLOTDS2' in argdict:
      PLOTDS2 = argdict['PLOTDS2']
    if 'DS2_SCALEFACTOR' in argdict:
      DS2_SCALEFACTOR = argdict['DS2_SCALEFACTOR']

  # Set the space in the turtle
  print("add space")
  turtle.add_parameter('space', surface)
  turtle.add_parameter('cumrotation', 0) # for parallel transport

  # Then plot the space surface
  if PLOTSPACE:
    umin,umax,vmin,vmax = surface.uv_domain()
    Du = 0.1
    Dv = 0.1
    points, quadindices = QuadifySurfEquation(surface.S,umin,umax,vmin,vmax,Du,Dv)
    # Option ccw: (counter-clockwise)
    # - set to False will change the orientation of normals defined by clockwise ordering of the points of a face
    #S1 = surf.patch.getUTangentAt(u,v)
    #S2 = surf.patch.getVTangentAt(u,v)
    nproduce ;(0)[@g(QuadSet(points,quadindices,ccw = CCW))]

    if PLOTDS2:
      ilist = np.arange(umin, umax, Du)
      ilist = np.append(ilist, umax)  # add the last bound as it is not done by arange
      # print("ilist after  = ", ilist)
      jlist = np.arange(vmin, vmax, Dv)
      jlist = np.append(jlist, vmax)  # case of a periodic list

      nproduce [
      for i in ilist:
        for j in jlist:
          ds = turtle.space.ds(i, j, Du/DS2_SCALEFACTOR, Dv/DS2_SCALEFACTOR)
          # plot ds2 at point (0,i,j)
          nproduce @M(turtle.space.S(i,j)) @O(ds)
      nproduce ]


# The turtle is augmented with a memory that stores the previous position and
# and velocity of the turtle at the surface: u,v,p,q.
# This computation can be done in either an absolute or a relative manner.
# The relative manner consists of computing the Euler angles for instance
# to move the HLU frame from the previous to the current position.
# It should correspond for instance to the correction term
# in the covariant derivative along the current geodesic and
# to the covariant derivative of the normal.

InitTurtle(gencoords):
  #pos = gencoords[0:2] # position
  #dir = gencoords[2:4] # direction
  # normalizes the initial direction to get a velocity of norm 1
  # in this way the geodesic equation will use parameter s that corresponds
  # to the curvilinear abscissa
  # nvelocity = turtle.space.normalize(pos,dir)

  turtle.add_parameter('uvpq',gencoords)
  head, up = riemannian_turtle_init(gencoords, turtle.space)
  u,v,p,q = gencoords
  #print("head = ", head)

  # Records if the turtle has reached the boundary of the (u,v) domain
  turtle.add_parameter('boundary_reached', False)

  nproduce @M( turtle.space.S(u,v) )
  nproduce @R(head,up)

# The following instructions redefined the compute the new riemmanian turtle state
# after turtle classical instructions.
# In addition to the turtle position, the turtle HLU frame is computed:
# - The Head direction that is a unit vector that point s in the direction
# of the movement (defined by p,q in the current state)
# - The Up direction that is a unit vector that coincides with the surface normal

#TODO: Factorize codes of F(), f() and LineTo() as a large part of the code is common to these functions
F(length):
  #0. Test if argument is null
  if length < 1e-100:
    # value considered as NULL:
    produce F(0)
  # 1. Find the nb of segments into which the curve should be divided
  # This nb, which should be < MAXSTEPLEN, will be used to divide the length into steplen=length/stepnb
  # by the riemannian_turtle_move_forward() function.
  stepnb = int(ceil(length / MAXSTEPLEN))
  steplen = length / stepnb
  #   e.g.
  #     - if len = 1.8 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(1.8) = 2.0 ==> steplen = 1.8 / 2.0 = 0.9 (which is <= MAXSTEPLEN)
  #     - if len = 0.6 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(0.6) = 1.0 ==> steplen = 0.6 / 1.0 = 0.6 (which is <= MAXSTEPLEN)

  # 2. Integrates the curve along the given length in stepnb steps
  uvpq_s = riemannian_turtle_move_forward(turtle.uvpq,turtle.space,length,stepnb)
  segnb = len(uvpq_s) # should be equal to stepnb
  assert stepnb == segnb

  # 3. draw all the small subsegments (that were returned by the integration)
  for i in range(segnb):
    flag = False
    # draw a line from the last visited point to the next one in abs coordinates
    uu, vv = uvpq_s[i][0], uvpq_s[i][1]
    if turtle.space.STAY_ON_BOUNDARY_U or turtle.space.STAY_ON_BOUNDARY_V:
      uu, vv, flag = turtle.space.check_coords_domain(uu,vv)
    nproduce LineTo(turtle.space.S(uu,vv))
    if flag: # the drawing stop when a boundary is reached
      break

  # 4. update the turtle's state with the last point of the computed curve
  # ask the parametric surface to check the computed coords and to possibly correct them
  turtle.boundary_reached = flag # by default boundary is not reached at (u,v)
  turtle.uvpq = turtle.space.check_coords(uvpq_s[i])

  u,v,p,q  = uvpq_s[i]

  '''
  # COVARIANT BASIS
  # Compute shitf tensor at u,v,
  A = turtle.space.Shift(u,v) # Compute shift tensor at the new u,v
  S1 = A[:,0] # first colum of A = first surface covariant vector in ambiant space
  S2 = A[:,1] # second column of A = second surface covariant vector in ambiant space

  # uses the shift tensor to transform the p,q vector
  # representing the coordinates of the covariant basis "on the curve" (one vector)
  # expressed in the "surface" covariant basis
  h = A.dot(np.array([p,q]))
  '''
  # TURTLE FRAME:
  S1,S2, velocity = turtle.space.covariant_basis_and_velocity(u,v,p,q)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u,v))
  #print ("head = ",head, " head norm = ", np.linalg.norm(head))
  #print ("up = ",up, " up norm = ", np.linalg.norm(up))

  # 5. Finally, orient the head of the turtle
  # according to what was computed for the mast point
  nproduce @R(head,up)

# To plot a geodesic from a point (u,v) to a point (ut,vt)
# The call in L-Py should be: LineTo((ut,vt), 30) which would draw a geodesic from
# the current position of the turtle to the target point S(ut,vt)
# Note step 3 to 5. are common with F and f

RiemannLineTo(target_coords, nb_points):

  # 1. Decode args
  ut,vt = target_coords

  u,v,p,q = turtle.uvpq
  space = turtle.space

  # 2. Call the algorithm to compute the geodesic between (u,v) and (ut,vt)
  # nb_points id the total required number of sampling point on the trajectory
  # including the two end-points
  uvpq_s = geodesic_to_point(space, (u,v), (ut,vt), nb_points, max_iter=LINETO_MAXITER, mu=0.2)

  #print('PATH FOUND:', uvpq_s)
  # TODO: the returned list can be None. This case should be handled.
  #uvpq_s = uvpq_s[:-1] # remove the first point (source)
  segnb = len(uvpq_s) # should be equal to stepnb
  print('nb segments: ', segnb, 'nb points:', nb_points)
  #assert segnb == nb_points-1  # 1 more points than segments in the returned list

  #BELOW IS A CODE THAT SHOULD BE SHARED WITH F and f ...
  # 3. draw all the small subsegments (that were returned by the integration)
  for i in range(segnb):
    flag = False
    # draw a line from the last visited point to the next one in abs coordinates
    uu, vv = uvpq_s[i][0], uvpq_s[i][1]
    if turtle.space.STAY_ON_BOUNDARY_U or turtle.space.STAY_ON_BOUNDARY_V:
      uu, vv, flag = turtle.space.check_coords_domain(uu,vv)
    # to draw intermediate tangent vectors
    #pp,qq = uvpq_s[i][2], uvpq_s[i][3]
    #velocity = turtle.space.shift_vector(uu,vv,pp,qq)
    #nproduce LineTo(turtle.space.S(uu,vv)) [;(2)DrawVect(velocity,0.5)]
    nproduce LineTo(turtle.space.S(uu, vv))
    if flag: # the drawing stop when a boundary is reached
      break

  # 4. update the turtle's state with the last point of the computed curve
  # ask the parametric surface to check the computed coords and to possibly correct them
  turtle.boundary_reached = flag # by default boundary is not reached at (u,v)
  turtle.uvpq = turtle.space.check_coords(uvpq_s[i])

  u,v,p,q  = uvpq_s[i]

  # TURTLE FRAME:
  # Compute shitf tensor at u,v,
  velocity = turtle.space.shift_vector(u,v,p,q)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u,v))
  #print ("head = ",head, " head norm = ", np.linalg.norm(head))
  #print ("up = ",up, " up norm = ", np.linalg.norm(up))

  # 5. Finally, orient the head of the turtle
  # according to what was computed for the mast point
  nproduce @R(head,up)

# Exactly the same algorithm as for F, but with a MoveTo instead of LineTo
f(length):
  #0. Test if argument is null
  if length < 1e-100:
    # value considered as NULL:
    produce F(0)
  # 1. Find the nb of segments into which the curve should be divided
  # This nb, which should be < MAXSTEPLEN, will be used to divide the length into steplen=length/stepnb
  # by the riemannian_turtle_move_forward() function.
  stepnb = int(ceil(length / MAXSTEPLEN))
  steplen = length / stepnb
  #   e.g.
  #     - if len = 1.8 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(1.8) = 2.0 ==> steplen = 1.8 / 2.0 = 0.9 (which is <= MAXSTEPLEN)
  #     - if len = 0.6 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(0.6) = 1.0 ==> steplen = 0.6 / 1.0 = 0.6 (which is <= MAXSTEPLEN)

  # 2. Integrates the curve along the given length in stepnb steps
  uvpq_s = riemannian_turtle_move_forward(turtle.uvpq,turtle.space,length,stepnb)
  segnb = len(uvpq_s) # should be equal to stepnb
  assert stepnb == segnb

  # 3. draw all the small subsegments (that were returned by the integration)
  for i in range(segnb):
    flag = False
    # draw a line from the last visited point to the next one in abs coordinates
    uu, vv = uvpq_s[i][0], uvpq_s[i][1]
    if turtle.space.STAY_ON_BOUNDARY_U or turtle.space.STAY_ON_BOUNDARY_V:
      uu, vv, flag = turtle.space.check_coords_domain(uu,vv)
    if flag: # the drawing stop when a boundary is reached
      break

  # 4. update the turtle's state with the last point of the computed curve
  # ask the parametric surface to check the computed coords and to possibly correct them
  turtle.boundary_reached = flag # by default boundary is not reached at (u,v)
  turtle.uvpq = turtle.space.check_coords(uvpq_s[i])

  u,v,p,q  = uvpq_s[i]

  # TURTLE FRAME:
  # Compute shitf tensor at u,v,
  velocity = turtle.space.shift_vector(u,v,p,q)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u,v))
  #print ("head = ",head, " head norm = ", np.linalg.norm(head))
  #print ("up = ",up, " up norm = ", np.linalg.norm(up))

  # 5. Finally, orient the head of the turtle
  # according to what was computed for the mast point
  nproduce @R(head,up)

+(angle):
  turtle.uvpq = riemannian_turtle_turn(turtle.uvpq,turtle.space,angle)

  u,v,p,q = turtle.uvpq
  # COVARIANT BASIS
  # Compute shitf tensor at u,v,
  velocity = turtle.space.shift_vector(u, v, p, q)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u,v))
  # print ("head = ",head, " head norm = ", np.linalg.norm(head))
  # print ("up = ",up, " up norm = ", np.linalg.norm(up))

  turtle.cumrotation += angle
  # print("Total turtle rotation during the path = ", turtle.cumrotation)

  nproduce @R(head,up)

-(angle):
  turtle.uvpq = riemannian_turtle_turn(turtle.uvpq,turtle.space,-angle)

  u,v,p,q = turtle.uvpq
  # COVARIANT BASIS
  # Compute shitf tensor at u,v,
  velocity = turtle.space.shift_vector(u, v, p, q)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u, v))
  # print ("head = ",head, " head norm = ", np.linalg.norm(head))
  # print ("up = ",up, " up norm = ", np.linalg.norm(up))

  turtle.cumrotation -= angle
  nproduce @R(head,up)

# Draw a vector that is parallel transported along the path that finishes at the current turtle position
# The vector if of norm = size and is assumed to make an angle angleRelHead at the origin of the turtle's path
# the initial direction of the path
ParallelTransportedArrow(angleRelHead,size):
  nproduce [+(angleRelHead-turtle.cumrotation)Arrow(size)]

CovariantBasis(size):
  surf = turtle.space
  u,v,p,q = turtle.uvpq
  S1, S2 = surf.covariant_basis(u, v)
  l1 = np.linalg.norm(S1)
  l2 = np.linalg.norm(S2)
  #nproduce [;(1)DrawVectnp(S1)][;(4)DrawVectnp(S2)]
  #nproduce [_(0.01);(2)LineRel(size*S1)@O(0.01)][_(0.01);(3)LineRel(size*S2)@O(0.01)]
  if not np.isclose(l1, 0.):
    nproduce [_(0.01);(2)PinpointRel(S1)Arrow(l1*size)]
  if not np.isclose(l2, 0.):
    nproduce [_(0.01);(3)PinpointRel(S2)Arrow(l2*size)]

# Draw a vector at the current position of the turtle
DrawVect(vect):
  # draw a line from the current position of the Turtle to the indicated position
  #nproduce _(0.01)LineRel(coord.x,coord.y,coord.z);(1)@O(0.01)
  l1 = np.linalg.norm(vect)
  #nproduce [_(0.01)LineRel(coord)]
  # PinpointRel(vect) orient the turtle frame so that H is pointing in the vect direction
  if not np.isclose(l1, 0.):
    nproduce [PinpointRel(vect)Arrow(l1)]

# Draw a vector at the current position of the turtle
DrawVect(vect, size):
  # draw a line from the current position of the Turtle to the indicated position
  #nproduce _(0.01)LineRel(coord.x,coord.y,coord.z);(1)@O(0.01)
  l1 = np.linalg.norm(vect)
  #nproduce [_(0.01)LineRel(coord)]
  # PinpointRel(vect) orient the turtle frame so that H is pointing in the vect direction
  if not np.isclose(l1,0.):
    nproduce [PinpointRel(vect)Arrow(l1*size)]

DrawPoint(uv,size):
  u,v = uv
  pos = turtle.space.S(u, v)
  nproduce [@M(pos) @O(size)]

endlsystem









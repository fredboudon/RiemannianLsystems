"""
	L-systems in Riemannian geometry

		Author: Ch. Godin, Inria
		Date: 2019-2020

	Interpretation rules to simulate geodesics on a curved surface with a riemannian implementation of
	the main turtle primitives: F, f, + and -

"""
#######################################################
# Generic Interpretation rules for Riemannian geometry
# (DO NOT EDIT)
#######################################################
# To import libs from other directories
#(append dynamically other dirs to PYTHONPATH variable)
from math import ceil

import sys
sys.path.append("../RiemannTurtleLib")

from importlib import reload

import surfaces
surfaces = reload(surfaces)
import riemannianturtle
riemannian_turtle = reload(riemannianturtle)

from surfaces import *
from riemannianturtle import *

module SetSpace(surface), InitTurtle(turtle_state), ParallelTransportedArrow(angleRelHead,size), CovariantBasis(size)

#Default values --> can be redefined below in the main file if needed
PLOTSPACE = True
PLOTDS2 = False

production:
interpretation:

# for drawing Vects: FIXME: @Fred can you create builtin primitives for this. Also this doesnot work in the %copyfile
#maximum depth : 2

# Two parameters are added to the turtle
# - turtle.space is added by SetSpace refers to the Riemanian space
# in which the turtle is moving
# - turtle.uvpq is added by init, refers to the initial position and velocity
# of the turtle.
# Sets the Riemannian space used by the turtle and draw it if required
# Plots the ds2 field if required
# A second argument is an array of optional parameters:
# args[0] --> DS2_SCALEFACTOR  (= 4 by default) to display the metrics ds2
SetSpace(surface,*args):
  # Set the space in the turtle
  turtle.add_parameter('space', surface)
  turtle.add_parameter('cumrotation', 0) # for parallel transport

  # Then plot the space surface
  if PLOTSPACE:
    umin,umax,vmin,vmax = surface.uv_domain()
    Du = 0.1
    Dv = 0.1
    points, quadindices = QuadifySurfEquation(surface.S,umin,umax,vmin,vmax,Du,Dv)
    # Option ccw: (counter-clockwise)
    # - set to False will change the orientation of normals defined by clockwise ordering of the points of a face
    #S1 = surf.patch.getUTangentAt(u,v)
    #S2 = surf.patch.getVTangentAt(u,v)
    nproduce ;(0)[@g(QuadSet(points,quadindices,ccw = True))]

    if PLOTDS2:
      ilist = np.arange(umin, umax, Du)
      ilist = np.append(ilist, umax)  # add the last bound as it is not done by arange
      # print("ilist after  = ", ilist)
      jlist = np.arange(vmin, vmax, Dv)
      jlist = np.append(jlist, vmax)  # case of a periodic list

      if len(args) != 0:
        DS2_SCALEFACTOR = args[0]
      else:
        DS2_SCALEFACTOR = 4. # default value

      nproduce [
      for i in ilist:
        for j in jlist:
          ds = turtle.space.ds(i, j, Du/DS2_SCALEFACTOR, Dv/DS2_SCALEFACTOR)
          # plot ds2 at point (0,i,j)
          nproduce @M(turtle.space.S(i,j)) @O(ds)
      nproduce ]


# The turtle is augmented with a memory that stores the previous position and
# and velocity of the turtle at the surface: u,v,p,q.
# This computation can be done in either an absolute or a relative manner.
# The relative manner consists of computing the Euler angles for instance
# to move the HLU frame from the previous to the current position.
# It should correspond for instance to the correction term
# in the covariant derivative along the current geodesic and
# to the covariant derivative of the normal.

InitTurtle(gencoords):
  #pos = gencoords[0:2] # position
  #dir = gencoords[2:4] # direction
  # normalizes the initial direction to get a velocity of norm 1
  # in this way the geodesic equation will use parameter s that corresponds
  # to the curvilinear abscissa
  # nvelocity = turtle.space.normalize(pos,dir)

  turtle.add_parameter('uvpq',gencoords)
  head, up = riemannian_turtle_init(gencoords, turtle.space)
  u,v,p,q = gencoords
  #print("head = ", head)

  nproduce @M( turtle.space.S(u,v) )
  nproduce @R(head,up)

# The following instructions redefined the compute the new riemmanian turtle state
# after turtle classical instructions.
# In addition to the turtle position, the turtle HLU frame is computed:
# - The Head direction that is a unit vector that point s in the direction
# of the movement (defined by p,q in the current state)
# - The Up direction that is a unit vector that coincides with the surface normal

F(length):
  #0. Test if argument is null
  if length < 1e-100:
    # value considered as NULL:
    produce F(0)
  # 1. Find the nb of segments into which the curve should be divided
  # This nb, which should be < MAXSTEPLEN, will be used to divide the length into steplen=length/stepnb
  # by the riemannian_turtle_move_forward() function.
  stepnb = int(ceil(length / MAXSTEPLEN))
  steplen = length / stepnb
  #   e.g.
  #     - if len = 1.8 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(1.8) = 2.0 ==> steplen = 1.8 / 2.0 = 0.9 (which is <= MAXSTEPLEN)
  #     - if len = 0.6 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(0.6) = 1.0 ==> steplen = 0.6 / 1.0 = 0.6 (which is <= MAXSTEPLEN)

  # 2. Integrates the curve along the given length in stepnb steps
  uvpq_s, head, up, S1, S2 = riemannian_turtle_move_forward(turtle.uvpq,turtle.space,length,stepnb)
  segnb = len(uvpq_s) # should be equal to stepnb
  assert stepnb == segnb

  # 3. draw all the small subsegments (that were returned by the integration)
  for i in range(segnb):
    # draw a line from the last visited point to the next one in abs coordinates
    nproduce LineTo(turtle.space.S(uvpq_s[i][0], uvpq_s[i][1]))

  '''
  delta_s = 0
  u = turtle.uvpq[0]
  v = turtle.uvpq[1]
  for i in range(segnb):
    # draw a line from the last visited point to the next one in abs coordinates
    delta_s += turtle.space.norm([u,v], [uvpq_s[i][0]-u,uvpq_s[i][1]-v])
    nproduce LineTo(turtle.space.S([uvpq_s[i][0],uvpq_s[i][1]]))
    u = uvpq_s[i][0]
    v = uvpq_s[i][1]

  print("Input length = ", length, " Drawn segment length = ", delta_s)
  '''
  # 4. update the turtle's state with the last point of the computed curve
  u,v,p,q = uvpq_s[-1]
  if v > np.pi / 2:
    print("*******          angles =", u, v, p, q)
    v = np.pi - v
    u = u + np.pi
    q = -q
    print("******* changing angles =", u, v, p, q)
  elif v < -np.pi / 2:
    print("*******          angles =", u, v, p, q)
    v = - np.pi - v
    u = u + np.pi
    q = -q
    print("******* changing angles =", u, v, p, q)

  turtle.uvpq = [u,v,p,q] #uvpq_s[-1]

  # 5. Finally, orient the head of the turtle
  # according to what was computed for the mast point
  nproduce @R(head,up)

# Exactly the same algorithm as for F, but with a MoveTo instead of LineTo
f(length):
  #0. Test if argument is null
  if length < 1e-100:
    # value considered as NULL:
    produce f(0)
  # 1. Find the nb of segments into which the curve should be divided
  stepnb = int(ceil(length / MAXSTEPLEN))
  steplen = length / stepnb
  #   e.g.
  #     - if len = 1.8 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(1.8) = 2.0 ==> steplen = 1.8 / 2.0 = 0.9 (which is <= MAXSTEPLEN)
  #     - if len = 0.6 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(0.6) = 1.0 ==> steplen = 0.6 / 1.0 = 0.6 (which is <= MAXSTEPLEN)

  # 2. Integrates the curve along the given length in stepnb steps
  uvpq_s, head, up, S1, S2 = riemannian_turtle_move_forward(turtle.uvpq,turtle.space,length,stepnb)
  segnb = len(uvpq_s) # should be equal to stepnb
  assert stepnb == segnb

  # 3. Move to the end of the last segment u,v (that were returned by the integration)
  nproduce MoveTo(turtle.space.S(uvpq_s[segnb-1][0],uvpq_s[segnb-1][1]))
  ''' 
  # Not necessary to pass through all intermediate segments as in F(), as they are not drawn
  for i in range(segnb):
    # draw a line from the last visited point to the next one in abs coordinates
    nproduce MoveTo(turtle.space.S([uvpq_s[i][0],uvpq_s[i][1]]))
  '''

  # 4. update the turtle's state with the last point of the computed curve
  turtle.uvpq = uvpq_s[-1]

  # 5. Finally, orient the head of the turtle
  # according to what was computed for the mast point
  nproduce @R(head,up)

+(angle):
  turtle.uvpq, head, up, S1, S2 = riemannian_turtle_turn(turtle.uvpq,turtle.space,angle)
  turtle.cumrotation += angle
  # print("Total turtle rotation during the path = ", turtle.cumrotation)
  nproduce @R(head,up)

-(angle):
  turtle.uvpq, head, up, S1, S2 = riemannian_turtle_turn(turtle.uvpq,turtle.space,-angle)
  turtle.cumrotation -= angle
  nproduce @R(head,up)

# Draw a vector that is parallel transported along the path that finishes at the current turtle position
# The vector if of norm = size and is assumed to make an angle angleRelHead at the origin of the turtle's path
# the initial direction of the path
ParallelTransportedArrow(angleRelHead,size):
  nproduce [+(angleRelHead-turtle.cumrotation)Arrow(size)]

CovariantBasis(size):
  surf = turtle.space
  u,v,p,q = turtle.uvpq
  S1, S2 = surf.covariant_basis(u, v)

  l1 = np.linalg.norm(S1)
  l2 = np.linalg.norm(S2)
  #nproduce [;(1)DrawVectnp(S1)][;(4)DrawVectnp(S2)]
  #nproduce [_(0.01);(2)LineRel(size*S1)@O(0.01)][_(0.01);(3)LineRel(size*S2)@O(0.01)]

  nproduce [_(0.01);(2)PinpointRel(S1)Arrow(l1*size)][_(0.01);(3)PinpointRel(S2)Arrow(l2*size)]

# Draw a vector at the current position of the turtle
DrawVect(vect):
  # draw a line from the current position of the Turtle to the indicated position
  #nproduce _(0.01)LineRel(coord.x,coord.y,coord.z);(1)@O(0.01)
  l1 = np.linalg.norm(vect)
  #nproduce [_(0.01)LineRel(coord)]
  # PinpointRel(vect) orient the turtle frame so that H is pointing in the vect direction
  nproduce [PinpointRel(vect)Arrow(l1)]

# Draw a vector at the current position of the turtle
DrawVect(vect, size):
  # draw a line from the current position of the Turtle to the indicated position
  #nproduce _(0.01)LineRel(coord.x,coord.y,coord.z);(1)@O(0.01)
  l1 = np.linalg.norm(vect)
  #nproduce [_(0.01)LineRel(coord)]
  # PinpointRel(vect) orient the turtle frame so that H is pointing in the vect direction
  nproduce [PinpointRel(vect)Arrow(l1*size)]


endlsystem

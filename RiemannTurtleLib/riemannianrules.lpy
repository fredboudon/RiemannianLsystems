"""
	L-systems in Riemannian geometry

		Author: Ch. Godin, Inria
		Date: 2019-2020

	Interpretation rules to simulate geodesics on a curved surface with a riemannian implementation of
	the main turtle primitives: F, f, + and -

"""
#######################################################
# Generic Interpretation rules for Riemannian geometry
# (DO NOT EDIT)
#######################################################
# To import libs from other directories
#(append dynamically other dirs to PYTHONPATH variable)
from math import ceil

import sys
sys.path.append("../RiemannTurtleLib")

from importlib import reload

import surfaces
surfaces = reload(surfaces)
import riemannianturtle
riemannian_turtle = reload(riemannianturtle)

from surfaces import *
from riemannianturtle import *

module SetSpace(surface, argdict)
module InitTurtle(turtle_state)
module ParallelTransportedArrow(angleRelHead,size)
module LineTo(uvcoords, stepnb)
module CovariantBasis(size)
module RiemannLineTo
#module DrawVect(vect) #FIXME: we should be able to declare same module with different signatures
module DrawVect(vect,size)
module MoveToPoint(uv)
module DrawTensor2(vect,size,color1,color2)
module DrawPoint
module StartIndirectInterpretation
module StopIndirectInterpretation
module ?T(parameters)
module PlotSpace()
module PlotDS2()
module StaticF
module Staticf

#Default values --> can be redefined below in the main file if needed
MAXSTEPLEN = 0.01

def plotspace(space,  colorvalfunc = None, cmap = 'jet', Du = 0.1, Dv = 0.1, CCW = True):
    umin,umax,vmin,vmax = space.uv_domain()
    points, quadindices, uvlist = QuadifySurfEquation(space.S,umin,umax,vmin,vmax,Du,Dv)
    if not colorvalfunc is None:
        from openalea.plantgl.scenegraph.colormap import PglColorMap
        values = [colorvalfunc(u,v) for u,v in uvlist]
        cm = PglColorMap(min(values), max(values), cmap)
        colors = [cm(v) for v in values]
    else:
        colors = None
    # Option ccw: (counter-clockwise)
    # - set to False will change the orientation of normals defined by clockwise ordering of the points of a face
    #S1 = surf.patch.getUTangentAt(u,v)
    #S2 = surf.patch.getVTangentAt(u,v)
    nproduce @g(QuadSet(points,quadindices,colorList=colors, ccw = CCW))

def plotds2(space, Du = 0.1, Dv = 0.1, DS2_SCALEFACTOR = 10):
      umin,umax,vmin,vmax = space.uv_domain()

      ilist = np.arange(umin, umax, Du)
      ilist = np.append(ilist, umax)  # add the last bound as it is not done by arange
      # print("ilist after  = ", ilist)
      jlist = np.arange(vmin, vmax, Dv)
      jlist = np.append(jlist, vmax)  # case of a periodic list

      nproduce [
      for i in ilist:
        for j in jlist:
          ds = space.ds(i, j, Du/DS2_SCALEFACTOR, Dv/DS2_SCALEFACTOR)
          # plot ds2 at point (0,i,j)
          nproduce @M(space.S(i,j)) @O(ds)
      nproduce ]

def forward(turtle, length, dl = 1):
  #0. Test if argument is null
  if length < 1e-100:
    # value considered as NULL:
    return
  # 1. Find the nb of segments into which the curve should be divided
  # This nb, which should be < MAXSTEPLEN, will be used to divide the length into steplen=length/stepnb
  # by the riemannian_turtle_move_forward() function.
  stepnb = int(ceil(length / dl))
  steplen = length / stepnb
  #   e.g.
  #     - if len = 1.8 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(1.8) = 2.0 ==> steplen = 1.8 / 2.0 = 0.9 (which is <= MAXSTEPLEN)
  #     - if len = 0.6 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(0.6) = 1.0 ==> steplen = 0.6 / 1.0 = 0.6 (which is <= MAXSTEPLEN)

  # 2. Integrates the curve along the given length in stepnb steps
  if turtle.indirect_interpretation:
    # move the turtle in the parameter space (u,v) as if in a euclidean space and then
    # draw on the result on the surface
    uvpq_s = parameterspace_turtle_move_forward(turtle.uvpq, turtle.space, length, stepnb)
  else:
    # move the turtle directly on the surface
    uvpq_s = riemannian_turtle_move_forward(turtle.uvpq,turtle.space,length,stepnb)

  segnb = len(uvpq_s) # should be equal to stepnb
  assert stepnb == segnb

  # 3. draw all the small subsegments (that were returned by the integration)
  for i in range(segnb):
    flag = False
    # draw a line from the last visited point to the next one in abs coordinates
    uu, vv = uvpq_s[i][0], uvpq_s[i][1]
    if turtle.space.STAY_ON_BOUNDARY_U or turtle.space.STAY_ON_BOUNDARY_V:
      uu, vv, flag = turtle.space.check_coords_domain(uu,vv)
    yield turtle.space.S(uu,vv)
    if flag: # the drawing stop when a boundary is reached
      break

  # 4. update the turtle's state with the last point of the computed curve
  # ask the parametric surface to check the computed coords and to possibly correct them
  turtle.boundary_reached = flag # by default boundary is not reached at (u,v)
  turtle.uvpq = turtle.space.check_coords(uvpq_s[i])


def endforward(turtle):

  u,v,p,q  = turtle.uvpq # uvpq_s[i]
  '''
  # COVARIANT BASIS
  # Compute shitf tensor at u,v,
  A = turtle.space.Shift(u,v) # Compute shift tensor at the new u,v
  S1 = A[:,0] # first colum of A = first surface covariant vector in ambiant space
  S2 = A[:,1] # second column of A = second surface covariant vector in ambiant space

  # uses the shift tensor to transform the p,q vector
  # representing the coordinates of the covariant basis "on the curve" (one vector)
  # expressed in the "surface" covariant basis
  h = A.dot(np.array([p,q]))
  '''
  # TURTLE FRAME:
  S1,S2, velocity = turtle.space.covariant_basis_and_velocity(u,v,p,q)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u,v))
  #print ("head = ",head, " head norm = ", np.linalg.norm(head))
  #print ("up = ",up, " up norm = ", np.linalg.norm(up))

  # 5. Finally, orient the head of the turtle
  # according to what was computed for the last point
  nproduce @R(head,up)


def cached_forward(cache, turtle, length, dl = 1):
    if len(cache) == 0:
        cache['points'] = list(forward(turtle, length, dl))
        cache['uvpq'] = turtle.uvpq
        cache['boundary_reached'] = turtle.boundary_reached
    for p in cache['points']:
        yield p

    turtle.uvpq = cache['uvpq']
    turtle.boundary_reached = cache['boundary_reached']

production:
interpretation:

# Two parameters are added to the turtle
# - turtle.space is added by SetSpace refers to the Riemanian space
# in which the turtle is moving
# - turtle.uvpq is added by init, refers to the initial position and velocity
# of the turtle.
# Sets the Riemannian space used by the turtle and draw it if required
# Plots the ds2 field if required
# A second argument is an array of optional parameters:
# args[0] --> DS2_SCALEFACTOR  (= 4 by default) to display the metrics ds2

# TODO: currently no optimal argument can be passed to LPy modules. Making it possible will simplify this call with a dict

SetSpace(surface, *args):
  # Set the space in the turtle
  turtle.add_parameter('space', surface)
  turtle.add_parameter('cumrotation', 0) # for parallel transport
  turtle.add_parameter('indirect_interpretation', False)  # to move the turtle indirectly in the parametre space and draw the result in the 3D space


PlotSpace(*args):
    if len(args) == 1 and type(args[0])==dict:
        plotspace(turtle.space, **args[0])
    else:
        plotspace(turtle.space, *args)

PlotDS2(*args):
    if len(args) == 1 and type(args[0])==dict:
        plotds2(turtle.space, **args[0])
    else:
        plotds2(turtle.space, *args)


StartIndirectInterpretation:
  turtle.indirect_interpretation = True

StopIndirectInterpretation:
  turtle.indirect_interpretation = False


# The turtle is augmented with a memory that stores the previous position and
# and velocity of the turtle at the surface: u,v,p,q.
# This computation can be done in either an absolute or a relative manner.
# The relative manner consists of computing the Euler angles for instance
# to move the HLU frame from the previous to the current position.
# It should correspond for instance to the correction term
# in the covariant derivative along the current geodesic and
# to the covariant derivative of the normal.

InitTurtle(gencoords):
  #pos = gencoords[0:2] # position
  #dir = gencoords[2:4] # direction
  # normalizes the initial direction to get a velocity of norm 1
  # in this way the geodesic equation will use parameter s that corresponds
  # to the curvilinear abscissa
  # nvelocity = turtle.space.normalize(pos,dir)

  lg=len(gencoords)
  if not (lg == 2 or lg == 4):
    raise ValueError('An array of size 2 or 4 is expected as an argument')

  if lg == 2: # only [u,v] is given --> add values for p,q = [1,0]
    gencoords += [1,0]

  turtle.add_parameter('uvpq',gencoords)
  head, up = riemannian_turtle_init(gencoords, turtle.space)
  u,v,p,q = gencoords
  #print("head = ", head)

  # Records if the turtle has reached the boundary of the (u,v) domain
  turtle.add_parameter('boundary_reached', False)

  nproduce @M( turtle.space.S(u,v) )
  nproduce @R(head,up)

# The following instructions redefined the compute the new riemmanian turtle state
# after turtle classical instructions.
# In addition to the turtle position, the turtle HLU frame is computed:
# - The Head direction that is a unit vector that point s in the direction
# of the movement (defined by p,q in the current state)
# - The Up direction that is a unit vector that coincides with the surface normal

#TODO: Factorize codes of F(), f() and LineTo() as a large part of the code is common to these functions
F(length):
    for p in forward(turtle, length, MAXSTEPLEN):
        nproduce LineTo(p)
    endforward(turtle)

F(length, topdiam):
    dl = MAXSTEPLEN
    stepnb = int(ceil(length / dl))
    currentdiam = turtle.getWidth()
    ddiam = (topdiam - currentdiam)/stepnb

    for p in forward(turtle, length, dl):
        currentdiam += ddiam
        nproduce LineTo(p, currentdiam)
    endforward(turtle)

F(length, dl, topdiam):
    stepnb = int(ceil(length / dl))
    currentdiam =turtle.getWidth()
    ddiam = (topdiam - currentdiam)/stepnb

    for p in forward(turtle, length, dl):
        currentdiam += ddiam
        nproduce LineTo(p, currentdiam)
    endforward(turtle)

f(length):
    for p in forward(turtle, length, MAXSTEPLEN):
        nproduce MoveTo(p)
    endforward(turtle)

f(length, dl):
    for p in forward(turtle, length, dl):
        nproduce MoveTo(p)
    endforward(turtle)

## Static Version

StaticF(length, cache):
    for p in cached_forward(cache, turtle, length, MAXSTEPLEN):
        nproduce LineTo(p)
    endforward(turtle)

StaticF(length, topdiam, cache):
    dl = MAXSTEPLEN
    stepnb = int(ceil(length / dl))
    currentdiam = turtle.getWidth()
    ddiam = (topdiam - currentdiam)/stepnb

    for p in cached_forward(cache, turtle, length, dl):
        currentdiam += ddiam
        nproduce LineTo(p, currentdiam)
    endforward(turtle)

StaticF(length, dl, topdiam, cache):
    stepnb = int(ceil(length / dl))
    currentdiam =turtle.getWidth()
    ddiam = (topdiam - currentdiam)/stepnb

    for p in cached_forward(cache, turtle, length, dl):
        currentdiam += ddiam
        nproduce LineTo(p, currentdiam)
    endforward(turtle)

Staticf(length, cache):
    for p in cached_forward(cache, turtle, length, MAXSTEPLEN):
        nproduce MoveTo(p)
    endforward(turtle)

Staticf(length, dl, cache):
    for p in cached_forward(cache, turtle, length, dl):
        nproduce MoveTo(p)
    endforward(turtle)



# To plot a geodesic from a point (u,v) to a point (ut,vt)
# The call in L-Py should be: LineTo((ut,vt), 30) which would draw a geodesic from
# the current position of the turtle to the target point S(ut,vt)
# Note step 3 to 5. are common with F and f

RiemannLineTo(target_coords, nb_points):

  # 1. Decode args
  ut,vt = target_coords

  u,v,p,q = turtle.uvpq
  space = turtle.space

  # 2. Call the algorithm to compute the geodesic between (u,v) and (ut,vt)
  # nb_points id the total required number of sampling point on the trajectory
  # including the two end-points

  uvpq_s = geodesic_to_point(space, (u,v), (ut,vt), nb_points, max_iter=LINETO_MAXITER)

  # if error, then stop here and produce nothing
  if uvpq_s == []:
    produce
  #print('PATH FOUND:', uvpq_s)
  # TODO: the returned list can be None. This case should be handled.
  #uvpq_s = uvpq_s[:-1] # remove the first point (source)
  segnb = len(uvpq_s) # should be equal to stepnb
  #print('nb segments: ', segnb, 'nb points:', nb_points)
  #assert segnb == nb_points-1  # 1 more points than segments in the returned list

  #BELOW IS A CODE THAT SHOULD BE SHARED WITH F and f ...
  # 3. draw all the small subsegments (that were returned by the integration)
  for i in range(segnb):
    flag = False
    # draw a line from the last visited point to the next one in abs coordinates
    uu, vv = uvpq_s[i][0], uvpq_s[i][1]
    if turtle.space.STAY_ON_BOUNDARY_U or turtle.space.STAY_ON_BOUNDARY_V:
      uu, vv, flag = turtle.space.check_coords_domain(uu,vv)
    # to draw intermediate tangent vectors
    #pp,qq = uvpq_s[i][2], uvpq_s[i][3]
    #velocity = turtle.space.shift_vector(uu,vv,pp,qq)
    #nproduce LineTo(turtle.space.S(uu,vv)) [;(2)DrawVect(velocity,0.5)]
    nproduce LineTo(turtle.space.S(uu, vv))
    if flag: # the drawing stop when a boundary is reached
      break

  # 4. update the turtle's state with the last point of the computed curve
  # ask the parametric surface to check the computed coords and to possibly correct them
  turtle.boundary_reached = flag # by default boundary is not reached at (u,v)
  turtle.uvpq = turtle.space.check_coords(uvpq_s[i])

  u,v,p,q  = uvpq_s[i]

  # TURTLE FRAME:
  # Compute shitf tensor at u,v,
  velocity = turtle.space.shift_vector(u,v,p,q)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u,v))
  #print ("head = ",head, " head norm = ", np.linalg.norm(head))
  #print ("up = ",up, " up norm = ", np.linalg.norm(up))

  # 5. Finally, orient the head of the turtle
  # according to what was computed for the mast point
  nproduce @R(head,up)


+(angle):

  if turtle.indirect_interpretation:
    turtle.uvpq = parameterspace_turtle_turn(turtle.uvpq, turtle.space,angle)
  else:
    turtle.uvpq = riemannian_turtle_turn(turtle.uvpq,turtle.space,angle)

  u,v,p,q = turtle.uvpq
  #print("retour = ", u,v,p,q)

  # COVARIANT BASIS
  # Compute shitf tensor at u,v,
  velocity = turtle.space.shift_vector(u, v, p, q)
  #print('velocity =' , velocity)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u,v))
  # print ("head = ",head, " head norm = ", np.linalg.norm(head))
  # print ("up = ",up, " up norm = ", np.linalg.norm(up))

  # TODO: Modify the following line as when the rotation takes place indirecty in the parameter space, the cumrotation is different
  turtle.cumrotation += angle
  # print("Total turtle rotation during the path = ", turtle.cumrotation)

  nproduce @R(head,up)

-(angle):

  if turtle.indirect_interpretation:
    turtle.uvpq = parameterspace_turtle_turn(turtle.uvpq, turtle.space, -angle)
  else:
    turtle.uvpq = riemannian_turtle_turn(turtle.uvpq, turtle.space, -angle)

  #turtle.uvpq = riemannian_turtle_turn(turtle.uvpq,turtle.space,-angle)

  u,v,p,q = turtle.uvpq
  # COVARIANT BASIS
  # Compute shitf tensor at u,v,
  velocity = turtle.space.shift_vector(u, v, p, q)
  head = velocity / np.linalg.norm(velocity)
  up = np.array(turtle.space.normal(u, v))
  # print ("head = ",head, " head norm = ", np.linalg.norm(head))
  # print ("up = ",up, " up norm = ", np.linalg.norm(up))

  # TODO: Modify the following line as when the rotation takes place indirectly in the parameter space, the cumrotation is different
  turtle.cumrotation -= angle

  nproduce @R(head,up)

MoveToPoint(uv):
  """Move at point (u,v) keeping the velocity [p,q] from the oroginal point """
  u, v = uv
  _,_,p,q = turtle.uvpq
  turtle.uvpq = [u,v,p,q]
  pos = turtle.space.S(u, v)
  nproduce @M(pos)

# Draw a vector that is parallel transported along the path that finishes at the current turtle position
# The vector if of norm = size and is assumed to make an angle angleRelHead at the origin of the turtle's path
# the initial direction of the path
ParallelTransportedArrow(angleRelHead,size):
  nproduce [+(angleRelHead-turtle.cumrotation)Arrow(size)]

CovariantBasis(size):
  surf = turtle.space
  u,v,p,q = turtle.uvpq
  S1, S2 = surf.covariant_basis(u, v)
  l1 = np.linalg.norm(S1)
  l2 = np.linalg.norm(S2)
  #nproduce [;(1)DrawVectnp(S1)][;(4)DrawVectnp(S2)]
  #nproduce [_(0.01);(2)LineRel(size*S1)@O(0.01)][_(0.01);(3)LineRel(size*S2)@O(0.01)]
  if not np.isclose(l1, 0.):
    nproduce [_(0.01);(2)PinpointRel(S1)Arrow(l1*size)]
  if not np.isclose(l2, 0.):
    nproduce [_(0.01);(3)PinpointRel(S2)Arrow(l2*size)]

# Draw a vector at the current position of the turtle
DrawVect(vect):
  # draw a line from the current position of the Turtle to the indicated position
  #nproduce _(0.01)LineRel(coord.x,coord.y,coord.z);(1)@O(0.01)
  l1 = np.linalg.norm(vect)
  #nproduce [_(0.01)LineRel(coord)]
  # PinpointRel(vect) orient the turtle frame so that H is pointing in the vect direction
  if not np.isclose(l1, 0.):
    nproduce [PinpointRel(vect)Arrow(l1)]

# Draw a vector at the current position of the turtle
DrawVect(vect, size):
  # draw a line from the current position of the Turtle to the indicated position
  #nproduce _(0.01)LineRel(coord.x,coord.y,coord.z);(1)@O(0.01)
  l1 = np.linalg.norm(vect)
  #nproduce [_(0.01)LineRel(coord)]
  # PinpointRel(vect) orient the turtle frame so that H is pointing in the vect direction
  if not np.isclose(l1,0.):
    nproduce [PinpointRel(vect)Arrow(l1*size)]

DrawTensor2Lines(pdirs, eigenvals, size, color_positive, color_negative):
  ''' 
  pidrs are the eigen vectors of the 2 tensor
  eigenvals are the two corresponding eigen values
  color positive (resp. negative) is used for positive (resp_negative) eigen values
  '''
  dirmax = pdirs[0] # max
  dirmin = pdirs[1]
  l0, l1 = eigenvals
  color0 = color_positive if l0 > 0 else color_negative
  color1 = color_positive if l1 > 0 else color_negative

  # draw a line from the current position of the Turtle to the indicated position
  # nproduce _(0.01)LineRel(coord.x,coord.y,coord.z);(1)@O(0.01)
  #l1 = np.linalg.norm(dir1)
  #l2 = np.linalg.norm(dir2)

  # nproduce [_(0.01)LineRel(coord)]
  # PinpointRel(vect) orient the turtle frame so that H is pointing in the vect direction
  if not np.isclose(l0, 0.):
    nproduce [ ;(color0)
    nproduce PinpointRel(dirmax)
    nproduce [turtle.F(l0 * size / 2)]
    nproduce PinpointRel(-dirmax)
    nproduce [turtle.F(l0 * size / 2)]
    nproduce ]
  if not np.isclose(l1, 0.):
    nproduce [ ;(color1)
    nproduce PinpointRel(dirmin)
    nproduce [turtle.F(l1 * size / 2)]
    nproduce PinpointRel(-dirmin)
    nproduce [turtle.F(l1 * size / 2)]
    nproduce ]

DrawTensor2Ellipsis(pdirs, eigenvals, size, thickness, color_positive, color_negative):
    ''' 
    TO BE FINISHED ...
    pidrs are the eigen vectors (in 3D) of the (0,2)-tensor
    eigenvals are the two corresponding eigen values
    color positive (resp. negative) is used for positive (resp_negative) eigen values
    
    The procedure draws an ellipsis corresponding to the tensor
    
    method 1:
      turtle's up = pdir[0] x pdir[1]
      set turtle's head = pdir[0] 
      Draw a deformed circle (scale factor eigenvals[0], eigenvals[1]) @ turtle's position
          
    method 2:
      turtle's up = pdir[0] x pdir[1]
      set turtle's head = pdir[0] + rotation(90)
    
      turtle's start = turtle's position + eigenvals[0] * pdir[0]
    
      draw ellipsis by integrating curvature
    '''

    dirmax = pdirs[0]  # max
    dirmin = pdirs[1]
    l0, l1 = eigenvals
    color0 = color_positive if l0 > 0 else color_negative
    color1 = color_positive if l1 > 0 else color_negative


DrawPoint(uv,size):
  u,v = uv
  pos = turtle.space.S(u, v)
  nproduce [@M(pos) @O(size)]

ClosedPolygon(polyline_uv, *args):
  resolution = 1.
  reverse = False

  if len(args) > 0:
    resolution = args[0]
  if len(args) > 1:
    reverse = args[1]

  if reverse:
    polyline_uv = list(reversed(polyline_uv))
    print(polyline_uv)
  if np.isclose(polyline_uv[0][0], polyline_uv[-1][0]) and np.isclose(polyline_uv[0][1], polyline_uv[-1][1]):
    del polyline_uv[-1]

  quads, minres, maxres = meshPolygon(polyline_uv, resolution)
  # print(quads)
  space = turtle.space
  for q in quads:
    # print("quad0=",q[0])
    pos0 = space.S(*q[0])
    pos1 = space.S(*q[1])
    pos2 = space.S(*q[2])
    pos3 = space.S(*q[3])
    # print("pos0", pos0)
    nproduce {MoveTo(pos0).MoveTo(pos1).MoveTo(pos2).MoveTo(pos3).}


?T(params):
    params['state'] = turtle.getParameters()
    for p, c in turtle._params.items():
        params[p] = c(getattr(turtle, p))
    t.append(params)
    produce ?T(params)

endlsystem









import openalea.plantgl.scenegraph.nurbsshape as ns
import importlib
importlib.reload(ns)
nurbsSphere = ns.nurbsSphere
import numpy as np
from numpy import arange
from geomdl import NURBS, BSpline
from geomdl import utilities
from geomdl import operations
from math import *

import sys
sys.path.append("../RiemannTurtleLib")

from surfaces import Sphere as CGSphere


radius = 10
if SphericalShape:
	sh = nurbCircle(1)
	d = 0.1
	s = 1 #0.05
else:
	sh = path1
	d = 0.1
	s = 1

sh = NurbsCurve([(p.x*radius,p.y*radius,0,p.z) for p in sh.ctrlPointList],degree=sh.degree,knotList=sh.knotList)


def to_nurbs_python(sh):
	surf = NURBS.Curve()
	surf.degree = sh.degree
	print(sh.ctrlPointList)
	npctrls = np.array(sh.ctrlPointList)
	shape = npctrls.shape
	print(shape)
	npctrls = np.reshape(npctrls,(shape[0],shape[1]))
	npctrls[:,0] *= npctrls[:,3]
	npctrls[:,1] *= npctrls[:,3]
	npctrls[:,2] *= npctrls[:,3]
	surf.set_ctrlpts(npctrls[:,:].tolist(), shape[0])
	surf.knotvector = list(sh.knotList)
	
	surf.evaluate()
	
	return surf

surf = to_nurbs_python(sh)


order = 1+int(ORDER2)

def l(l):
  return s


def derivatives(u, order):
    du = 0.01
    from scipy.misc import derivative
    def upt(ui):
        print('ui:',str(ui))
        ui = min(1,max(0,ui))
        pt = np.array(sh.getPointAt(ui))
        print(pt)
        return pt
    
    return derivative(upt, u, du, n=order)



extern(ExtEval = True)

Axiom: 
  # nproduce @g(sh)
  nproduce _(d) 
  #nproduce ,(5)@g(sh)
  nproduce ,(5)@g(sh)
  
  values = [u for u in arange(0.,1.1,0.1)]
  
  for u in values:
      p = sh.getPointAt(u)
      du1 = sh.getDerivativeAt(u,order)
      
      skl = surf.derivatives(u,order)
      du2 = skl[order]
      
      du3 = derivatives(u,order)
      
      
      nproduce [ @M(p) ,(2)@O(d*2) 
      # red plantgl
      nproduce [,(3) PinpointRel(du1) Arrow(l(norm(du1))) ] 
      # purple python nurbs
      nproduce [,(6) PinpointRel(du2) Arrow(l(norm(du2))) ] 
      # green derivative
      nproduce [,(8) PinpointRel(du3) Arrow(l(norm(du3))) ] 
      nproduce ]
      

derivation length: 1
production:


interpretation:


endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_6 = pgl.Material("Color_6" , ambient = (78,16,57) , diffuse = 2.30769 , )
	Color_6.name = "Color_6"
	context.turtle.setMaterial(6,Color_6)
	Color_7 = pgl.Material("Color_7" , ambient = (67,38,0) , diffuse = 2.68657 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (0,44,0) , diffuse = 1.29545 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (76,152,25) , diffuse = 1.02632 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	scalars = [('ExtEval', 'Bool', False), ('SphericalShape', 'Bool', True), ('IsoLine', 'Bool', False), ('ORDER2', 'Bool', False), ('DIR', 'Integer', 2, 1, 3)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
	import openalea.plantgl.all as pgl
	patch1 = pgl.NurbsPatch(	
	    pgl.Point4Matrix([[(0, -0.5, -0.5, 1), (0, -0.5, -0.25, 1), (0, -0.5, 0, 3.9658), (0, -0.5, 0.25, 10.8266), (0, -0.5, 0.5, 27.4997)], [(0, -0.25, -0.5, 1), (0, -0.25, -0.25, 1), (0, -0.25, 0, 3.9658), (0, -0.25, 0.25, 10.8266), (0, -0.25, 0.5, 10.8266)], [(0, 0, -0.5, 1), (0, 0, -0.25, 1), (0, 0, 0, 3.9658), (0, 0, 0.25, 3.9658), (0, 0, 0.5, 3.9658)], [(0, 0.25, -0.5, 1), (0, 0.25, -0.25, 1), (0, 0.25, 0, 1), (0, 0.25, 0.25, 1), (0, 0.25, 0.5, 1)], [(0, 0.5, -0.5, 1), (0, 0.5, -0.25, 1), (0, 0.5, 0, 1), (0, 0.5, 0.25, 1), (0, 0.5, 0.5, 1)]]) , 
ustride = 25 , vstride = 22 , 	    )
	patch1.name = "patch1"
	patch2 = pgl.NurbsPatch(	
	    pgl.Point4Matrix([[(0, -0.5, -0.5, 1), (0, -0.5, -0.25, 1), (0, -0.5, 0, 1), (0, -0.5, 0.25, 1), (0, -0.5, 0.5, 1)], [(0, -0.25, -0.5, 1), (0, -0.25, -0.25, 1), (0, -0.25, 0, 1), (0, -0.25, 0.25, 1), (0, -0.25, 0.5, 1)], [(0, 0, -0.5, 1), (0, 0, -0.25, 1), (0.50213, -0.0324848, -0.0170653, 3.959), (0.0321118, 0.0279851, 0.237368, 1), (0, 0, 0.5, 1)], [(0, 0.25, -0.5, 1), (0, 0.25, -0.25, 1), (0, 0.25, 0, 1), (0, 0.25, 0.25, 1), (0, 0.25, 0.5, 1)], [(0, 0.5, -0.5, 1), (0, 0.5, -0.25, 1), (0, 0.5, 0, 1), (0, 0.5, 0.25, 1), (0, 0.5, 0.5, 1)]]) , 
ustride = 10 , vstride = 10 , 	    )
	patch2.name = "patch2"
	patch4 = pgl.NurbsPatch(	
	    pgl.Point4Matrix([[(0, -0.5, -0.5, 1), (0, -0.5, -0.25, 1), (0, -0.5, 0, 1), (0, -0.5, 0.25, 1), (0, -0.5, 0.5, 1)], [(0, -0.25, -0.5, 1), (0, -0.25, -0.25, 1), (0, -0.25, 0, 1), (0, -0.25, 0.25, 1), (0, -0.25, 0.5, 1)], [(0, 0, -0.5, 1), (0, 0, -0.25, 1), (1.64182, 0, 0, 1), (0, 0, 0.25, 1), (0, 0, 0.5, 1)], [(0, 0.25, -0.5, 1), (0, 0.25, -0.25, 1), (0, 0.25, 0, 1), (0, 0.25, 0.25, 1), (0, 0.25, 0.5, 1)], [(0, 0.5, -0.5, 1), (0, 0.5, -0.25, 1), (0, 0.5, 0, 1), (0, 0.5, 0.25, 1), (0, 0.5, 0.5, 1)]]) , 
ustride = 10 , vstride = 10 , 	    )
	patch4.name = "patch4"
	import openalea.plantgl.all as pgl
	path1 = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.479592, -0.00612245, 1),(-0.406122, 0.206122, 1),(-0.191156, 0.310204, 1),(-0.0795918, 0.326531, 1),(0.276871, 0.242857, 1),(0.5, 0, 1),(0.408163, -0.261224, 1),(0.208163, -0.373469, 1),(-0.189796, -0.406122, 1),(-0.469388, -0.310204, 1),(-0.47551, -0.0285714, 1)]) , 
	    )
	path1.name = "path1"
	panel_0 = ({'name': 'Panel 1', 'active': True, 'visible': True},[('NurbsPatch',patch1),('NurbsPatch',patch2),('NurbsPatch',patch4),('Curve2D',path1)])
	parameterset = [panel_0,]
	context["__functions__"] = []
	context["__curves__"] = [('path1',path1),]
	context["__parameterset__"] = parameterset
	context["patch1"] = patch1
	context["patch2"] = patch2
	context["patch4"] = patch4
	context["path1"] = path1

from math import ceil

# To import libs from other directories
#(append dynamically other dirs to PYTHONPATH variable)
from importlib import reload

import riemann_lsystem.surfaces
surfaces = reload(riemann_lsystem.surfaces)
import riemann_lsystem.riemannianturtle
riemannian_turtle = reload(riemann_lsystem.riemannianturtle)

from riemann_lsystem.surfaces import *
from riemann_lsystem.riemannianturtle import *

%pastefile ../src/riemann_lsystem/riemannianrules.lpy
module SetSpace(surface), InitTurtle(turtle_state)

production:
interpretation:


#######################################################
# Generic Interpretation rules for Riemannian geometry
# (DO NOT EDIT)
#######################################################

# Two parameters are added to the turtle
# - turtle.space is added by SetSpace refers to the Riemanian space
# in which the turtle is moving
# - turtle.uvpq is added by init, refers to the initial position and velocity
# of the turtle.
# Sets the Riemanian space used by the turtle and draw it if required
SetSpace(surface, Du, Dv):
  # Set the space in the turtle
  turtle.add_parameter('space', surface)

  # Then plot the space surface
  if PLOTSPACE:
    umin,umax,vmin,vmax = surface.uv_domain()
    points, quadindices = QuadifySurfEquation(surface.S,umin,umax,vmin,vmax,Du=Du,Dv=Dv)
    # Option ccw: (counter-clockwise)
    # - set to False will change the orientation of normals defined by clockwise ordering of the points of a face
    #S1 = surf.patch.getUTangentAt(u,v)
    #S2 = surf.patch.getVTangentAt(u,v)
    nproduce ;(0)[@g(QuadSet(points,quadindices,ccw = True))]

# The turtle is augmented with a memory that stores the previous position and
# and velocity of the turtle at the surface: u,v,p,q.
# This computation can be done in either an absolute or a relative manner.
# The relative manner consists of computing the Euler angles for instance
# to move the HLU frame from the previous to the current position.
# It should correspond for instance to the correction term
# in the covariant derivative along the current geodesic and
# to the covariant derivative of the normal.

InitTurtle(uvpq):
  turtle.add_parameter('uvpq',uvpq)
  head, up = riemannian_turtle_init(uvpq, turtle.space)
  u,v,p,q = uvpq
  #print("head = ", head)
  nproduce ;(2)_(0.02)
  nproduce @M( turtle.space.S(u,v) )
  nproduce @R(head,up)@O(0.02)

# The following instructions redefined the compute the new riemmanian turtle state
# after turtle classical instructions.
# In addition to the turtle position, the turtle HLU frame is computed:
# - The Head direction that is a unit vector that point s in the direction
# of the movement (defined by p,q in the current state)
# - The Up direction that is a unit vector that coincides with the surface normal

F(length):
  #0. Test if argument is null
  if length < 1e-100:
    # value considered as NULL:
    produce F(0)
  # 1. Find the nb of segments into which the curve should be divided
  stepnb = int(ceil(length / MAXSTEPLEN))
  steplen = length / stepnb
  #   e.g.
  #     - if len = 1.8 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(1.8) = 2.0 ==> steplen = 1.8 / 2.0 = 0.9 (which is <= MAXSTEPLEN)
  #     - if len = 0.6 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(0.6) = 1.0 ==> steplen = 0.6 / 1.0 = 0.6 (which is <= MAXSTEPLEN)

  # 2. Integrates the curve along the given length in stepnb steps
  uvpq_s, head, up, S1, S2 = riemannian_turtle_move_forward(turtle.uvpq,turtle.space,length,stepnb)
  segnb = len(uvpq_s) # should be equal to stepnb
  assert stepnb == segnb

  # 3. sets line width first
  nproduce _(LINEWIDTH)

  # 4. draw all the small subsegments (that were returned by the integration)
  for i in range(segnb):
    # draw a line from the last visited point to the next one in abs coordinates
    nproduce LineTo(turtle.space.S(uvpq_s[i][0],uvpq_s[i][1]))

  # 5. update the turtle's state with the last point of the computed curve
  turtle.uvpq = uvpq_s[-1]

  # 6. Finally, orient the head of the turtle
  # according to what was computed for the mast point
  nproduce @R(head,up)

# Exactly the same algorithm as for F, but with a MoveTo instead of LineTo
f(length):
  #0. Test if argument is null
  if length < 1e-100:
    # value considered as NULL:
    produce f(0)
  # 1. Find the nb of segments into which the curve should be divided
  stepnb = int(ceil(length / MAXSTEPLEN))
  steplen = length / stepnb
  #   e.g.
  #     - if len = 1.8 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(1.8) = 2.0 ==> steplen = 1.8 / 2.0 = 0.9 (which is <= MAXSTEPLEN)
  #     - if len = 0.6 and MAXSTEPLEN = 1.0
  #   stepnb = ceil(0.6) = 1.0 ==> steplen = 0.6 / 1.0 = 0.6 (which is <= MAXSTEPLEN)

  # 2. Integrates the curve along the given length in stepnb steps
  uvpq_s, head, up, S1, S2 = riemannian_turtle_move_forward2(turtle.uvpq,turtle.space,length,stepnb)
  segnb = len(uvpq_s) # should be equal to stepnb
  assert stepnb == segnb
  # 3. sets line width first
  nproduce _(LINEWIDTH)

  # 4. draw all the small subsegments (that were returned by the integration)
  for i in range(segnb):
    # draw a line from the last visited point to the next one in abs coordinates
    nproduce MoveTo(turtle.space.S(uvpq_s[i][0],uvpq_s[i][1]))

  # 5. update the turtle's state with the last point of the computed curve
  turtle.uvpq = uvpq_s[-1]

  # 6. Finally, orient the head of the turtle
  # according to what was computed for the mast point
  nproduce @R(head,up)

+(angle):
  turtle.uvpq, head, up, S1, S2 = riemannian_turtle_turn(turtle.uvpq,turtle.space,angle)
  nproduce @R(head,up)

-(angle):
  turtle.uvpq, head, up, S1, S2 = riemannian_turtle_turn(turtle.uvpq,turtle.space,-angle)
  nproduce @R(head,up)


endlsystem

# Figure 24: Modeling tropism using abstract Riemannian spaces.

# Abstract Riemannian space with point-like source of metric distorsion, simulating shadow-avoiding behaviour of trees.

"""
	L-systems in Riemannian geometry
	
		Author: Ch. Godin, Inria
		Date: 2019-2022

	Example of a tree growing in a 2D intrinsic Riemaniann space
	
	
"""

from random import seed

%pastefile ../src/riemann_lsystem/riemannianrules.lpy

######################################
# DEFINITION OF THE METRIC (INTRINSIC)
######################################

extern(FIELD_STRENGTH = 0.7) # 0 is no field, 1. is max field

# Point source metric : metric generated by a point source

# Parameters used both for psi and psd metric
# metric is diagonal in the local frame (r,theta). 
# These formula define r, theta, and control ratio parameters
def ps_params(u,v,source,ry,rz):
    p = np.array((u, v))
    s = np.array(source)
    r = np.linalg.norm(s - p)

    costheta = (s[0] - u) / r
    sintheta = (s[1] - v) / r

    ratioy = r / ry
    ratioz = r / rz
    return r,costheta,sintheta,ratioy,ratioz


alpha = 0.20

# Point source metric (psi) (increasing with radius to the source)
def g11_ps(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v, *args)
    return ( alpha * r**2 * FIELD_STRENGTH + (1-FIELD_STRENGTH) )
    #return ( alpha * 1/r * FIELD_STRENGTH + (1-FIELD_STRENGTH) ) # works with alpha = 2
# g11 with swapped u,v --> v,u (to carry out devivative of first argument)
def g11s_ps(v,u,*args):
    return g11_ps(u,v,*args)

# g12 == g21
def g12_ps(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v,*args)
    return 0
def g12s_ps(v,u,*args):
    return g12_ps(u,v,*args)

def g22_ps(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v,*args)
    return ( alpha * r**2 * FIELD_STRENGTH + (1-FIELD_STRENGTH) )
    #return ( alpha * 1/r * FIELD_STRENGTH + (1-FIELD_STRENGTH) ) # works with alpha = 2
def g22s_ps(v,u,*args):
    return g22_ps(u,v,*args)


# Point source metric (psi) (increasing with radius to the source)
def g11_psi(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v, *args)
    return ratioy*costheta**2 + ratioz*sintheta**2
# g11 with swapped u,v --> v,u (to carry out devivative of first argument)
def g11s_psi(v,u,*args):
    return g11_psi(u,v,*args)

# g12 == g21
def g12_psi(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v,*args)
    return (ratioy-ratioz)*costheta*sintheta
def g12s_psi(v,u,*args):
    return g12_psi(u,v,*args)

def g22_psi(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v,*args)
    return ratioy*sintheta**2 + ratioz*costheta**2
def g22s_psi(v,u,*args):
    return g22_psi(u,v,*args)


#######################
# Units
#######################
# Scaling model in graphic scene
meter = 1.0 # An object of 1 meter is mapped onto a graphic unit size of 1.0
            # (F(1) for instance corresponds to a forward move of 1 meter)
cm = 0.01 * meter

# Surface parameters
R = 1. * meter   # Radius of the sphere in meter

#######################
# DISPLAY PARAMETERS
#######################


# maximum len of subdivision step required to draw any line on the surface
# this controls the resolution of the geodesic plot with respect to the
# surface curvature
MAXSTEPLEN = 1 * cm  # Should be > 0.0

# Width to draw the geodesics
LINEWIDTH  = 1 * cm

# To control the Frame size
FRAMESIZE  = 0.3 * meter
FRAMEWIDTH = 0.5 * cm

#######################
# SIMULATION PARAMETERS
#######################

extern(TREE = True)

# Tighten the nec of the pin form structure to see that the geodesic 
# at some threshold is doomed to stay in the lower part and cannot reach the other part
nb_seg = 10 # nb of segment to draw the geodesic (defines the parameter of the F)
            # To draw one geodesic, set it to 1 and set dashed to False
ilen = 0.4 # 
seed(0)

#Metric parameters for psi and psd
#source = (1.1,3.2) # simu 1
source = (1.6,1.8) #Simu 2
ry = 1.
rz = 2.

Axiom: 
  # Sets the Riemanian space in which the turtle will move
  params = (source, ry, rz)
  # choice of functions used to define the intrinsic metric (see above their definition
  metric_funcs = {'g11' : g11_ps, 'g12' : g12_ps, 'g22' : g22_ps, 'g11s' : g11s_ps, 'g12s' : g12s_ps, 'g22s' : g22s_ps}  
  #metric_funcs = {'g11' : g11_psi, 'g12' : g12_psi, 'g22' : g22_psi, 'g11s' : g11s_psi, 'g12s' : g12s_psi, 'g22s' : g22s_psi}
  #metric_funcs = {'g11' : g11_psd, 'g12' : g12_psd, 'g22' : g22_psd, 'g11s' : g11s_psd, 'g12s' : g12s_psd, 'g22s' : g22s_psd}

  nproduce SetSpace(RiemannianSpace2D(**metric_funcs, umin = -2., umax = 2., vmin = -0.0, vmax = 3., metric_tensor_params = params))
  nproduce ;(0)PlotSpace
  nproduce PlotDS2(dict(DS2_SCALEFACTOR = 8))
  nproduce InitTurtle([0.0,0.0,0.0,1])
  #nproduce -(30)
  # nproduce InitTurtle([0.9,1.4,-0.7,-0.2]) # Gowing away from the source ...

  # for hyperbolic geometry:
  # just uncomment the hyperbolic metric in surfaces.py and comment the other one
  # Geodesics are semi-circles of the Poincar√©-Beltrami half plane
  #nproduce InitTurtle([-1.5,0.1,0.3,0.9])
  
  nproduce S;(6)_(LINEWIDTH)A(0)@O(0.03)_(FRAMEWIDTH)
 

derivation length: 6 # set to 12 for a hyperbolic geodesic, and 7 for hyperbolic tree
production:

A(n):
  # branching angle
  if n % 2 == 0:
    ba = 30
  else:
    ba = -30
  nproduce StaticF(ilen) 
  if TREE:
    nproduce [+(ba)A(n+1)]
  nproduce A(n+1)

interpretation:

A(n):
  produce ;(2)@O(0.03)

S: 
  source3D = [0]
  source3D += source
  #print(source3D)
  produce [MoveTo(source3D);(4)@O(0.1)]

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_14 = pgl.Material("Color_14" , transparency = 0.45 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
	context.animation_timestep = 0.001
__references__ = '#'

# Figure 23: Different geometric embeddings of the same intrinsic von Koch flake curve. 

# A von Koch flake moves progressively from left to right ( in an abstract 2D space where the metric linearly depends on the distance at the origin (small yellow dot). During this move, the flake is deformed by the metric. Geodesics forming the segments close to the origin tend to be strongly curved, thus deforming the entire flake. At the end of the sequence, the metrics becomes more homogeneous over the entire flake, which is less and less distorted.

"""
	L-systems in Riemannian geometry
	
		Author: Ch. Godin, Inria
		Date: 2019-2022

	Example of a 2D intrinsic Riemaniann space
	Space is curved by a point source (represented as a sphere)
	Coordinates are the usual cartesian coords, but the metric is different at different points.
	
"""

import numpy as np
from math import ceil
from random import random, seed

%pastefile ../src/riemann_lsystem/riemannianrules.lpy

######################################
# DEFINITION OF THE METRIC (INTRINSIC)
######################################

# Point source metric : metric generated by a point source

# Parameters used both for psi and psd metric
# metric is diagonal in the local frame (r,theta). 
# These formula define r, theta, and control ratio parameters
def ps_params(u,v,source,ry,rz):
    p = np.array((u, v))
    s = np.array(source)
    r = np.linalg.norm(s - p)

    costheta = (s[0] - u) / r
    sintheta = (s[1] - v) / r

    ratioy = r / ry
    ratioz = r / rz
    return r,costheta,sintheta,ratioy,ratioz
    

alpha = 1.0
# Point source metric (psi) (increasing with radius to the source)
def g11_ps(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v, *args)
    return alpha * r**1.5
# g11 with swapped u,v --> v,u (to carry out devivative of first argument)
def g11s_ps(v,u,*args):
    return g11_ps(u,v,*args)

# g12 == g21
def g12_ps(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v,*args)
    return 0
def g12s_ps(v,u,*args):
    return g12_ps(u,v,*args)

def g22_ps(u,v,*args):
    r, costheta, sintheta, ratioy, ratioz = ps_params(u, v,*args)
    return alpha * r**1.5
def g22s_ps(v,u,*args):
    return g22_ps(u,v,*args)


#######################
# SIMULATION PARAMETERS
#######################

#Metric parameters for psi and psd
source = (0.0,1.)
ry = 3.
rz = 3.

nbsteps = 100
initx = -1.9
endx = 1
dx = (endx-initx)/nbsteps


Axiom: 
  # Sets the Riemanian space in which the turtle will move
  params = (source, ry, rz)
  # choice of functions used to define the intrinsic metric (see above their definition
  metric_funcs = {'g11' : g11_ps, 'g12' : g12_ps, 'g22' : g22_ps, 'g11s' : g11s_ps, 'g12s' : g12s_ps, 'g22s' : g22s_ps}
  nproduce SetSpace(RiemannianSpace2D(**metric_funcs, umin = -2, umax = 2., vmin = -1, vmax = 2.5, metric_tensor_params = params))
  nproduce InitTurtle([initx,0.12,0.9,0.4])
  nproduce [S] 
  nproduce ;(3)_(0.01)G(2,0)-(120)G(2,0)-(120)G(2,0)



derivation length: nbsteps
production:
InitTurtle(v) :
  v[0] += dx
  produce InitTurtle(v)

decomposition:
maximum depth: 4
G(x,o):
  if o == 2:
    nproduce F(x/3.)+(60)F(x/3.)-(120)F(x/3.)+(60)+F(x/3.)
  else:
     nproduce G(x/3.,o+1)+(60)G(x/3.,o+1)-(120)G(x/3.,o+1)+(60)+G(x/3.,o+1)

interpretation:

A(n):
  produce _(FRAMEWIDTH) Frame(FRAMESIZE)

S: 
  source3D = [0]
  source3D += source
  produce [MoveTo(source3D);(4)@O(0.05)]
  
endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_5 = pgl.Material("Color_5" , ambient = (0,0,60) , diffuse = 3 , transparency = 0.69 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	Color_14 = pgl.Material("Color_14" , transparency = 0.45 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
	context.animation_timestep = 0.001
	context.options.setSelection('Axiom decomposition',1)
__references__ = '#'
